<?xml version="1.0" encoding="UTF-8" standalone="no"?><Packages><Package depth="../../../../" display="com.softwareag.connectivity.control" name="com.softwareag.connectivity.control"><Type category="Event" name="AckRequired"><Description><![CDATA[Request from a connectivity chain to the application, asking it to reliably acknowledge all events that came from the chain immediately prior to this AckRequired.

 This event will be sent to the default channel of that chain. That is, your EPL will not normally need to subscribe to any extra channels to receive these requests, if it is already receiving regular events from that chain.

 A reliable-messaging-aware transport will issue these requests with as large an interval as it can get away with, based on the constraints of the external messaging system. So if your application has a "commit" mechanism that has a large fixed cost (for example, a filesystem sync, a database commit or an expensive computation) then doing a commit and acknowledgment on and only on AckRequired requests makes sense.

 Do not rely on these requests being high frequency or timely; the functional behaviour of your application should not depend on them, especially if latency is important. Only the operations required for safely preserving the effect of incoming events should be tied to AckRequired requests.]]></Description><Summary><![CDATA[Request from a connectivity chain to the application, asking it to reliably acknowledge all events that came from the chain immediately prior to this AckRequired.]]></Summary><TypeParameters/><See action="ackUpTo" package="com.softwareag.connectivity" type="Chain"><Description><![CDATA[Otherwise, you can use this action to perform per-event acknowledgments if the message id of each incoming event is available.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="messageId" type="string"><Description><![CDATA[The message id of the regular event received immediately before this AckRequired.]]></Description><Summary><![CDATA[The message id of the regular event received immediately before this AckRequired.]]></Summary><TypeParameters/></Member><Member name="chainId" type="string"><Description><![CDATA[Id of the connectivity chain that this request has come from.]]></Description><Summary><![CDATA[Id of the connectivity chain that this request has come from.]]></Summary><TypeParameters/></Member><Action name="ackUpTo" staticNature=""><Description><![CDATA[Acknowledge all previously received events from the connectivity chain as having been reliably processed by your application.]]></Description><Summary><![CDATA[Acknowledge all previously received events from the connectivity chain as having been reliably processed by your application.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action></Type><Type category="Event" name="Flush" private="true"><Description><![CDATA[Used by com.softwareag.connectivity.Chain#flush(). This event gets sent to the control channel of the chain.]]></Description><Summary><![CDATA[Used by com.softwareag.connectivity.Chain#flush(). This event gets sent to the control channel of the chain.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="requestId" type="integer"><TypeParameters/></Member><Member name="replyTo" type="context"><TypeParameters/></Member></Type><Type category="Event" name="FlushAck"><Description><![CDATA[Response to a flush request.]]></Description><Summary><![CDATA[Response to a flush request.]]></Summary><TypeParameters/><See action="flush" package="com.softwareag.connectivity" type="Chain"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="requestId" type="integer"><Description><![CDATA[Identifies the corresponding flush request.]]></Description><Summary><![CDATA[Identifies the corresponding flush request.]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="AckUpTo" private="true"><Description><![CDATA[Used for com.softwareag.connectivity.Chain#ackUpTo() and com.softwareag.connectivity.control.AckRequired#ackUpTo() , sent to the control channel of the chain.]]></Description><Summary><![CDATA[Used for com.softwareag.connectivity.Chain#ackUpTo() and com.softwareag.connectivity.control.AckRequired#ackUpTo() , sent to the control channel of the chain.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="messageId" type="string"><TypeParameters/></Member></Type></Package><Package depth="../../" display="apamax.training" name="apamax.training"><Type category="Event" name="RobotManager" private="true"><Description><![CDATA[A manager object which handles robot status updates and requests.]]></Description><Summary><![CDATA[A manager object which handles robot status updates and requests.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="apamax.training" type="RobotStatus"/></Sends><Listens><Reference package="apamax.training" type="RegisterRobot"/><Reference package="apamax.training" type="RequestRobotStatus"/><Reference package="apamax.training" type="RobotError"/></Listens><Spawns/><Member name="robots" private="true" type="dictionary"><Parameters><Parameter type="integer"/><Parameter type="string"/></Parameters><Description/><Summary/><TypeParameters/></Member><Action name="init" private="true" staticNature=""><Description/><Summary/><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="apamax.training" type="RobotStatus"/></Sends><Listens><Reference package="apamax.training" type="RobotError"/><Reference package="apamax.training" type="RequestRobotStatus"/><Reference package="apamax.training" type="RegisterRobot"/></Listens><Spawns/></Action></Type><Type category="Event" name="RobotError"><Description><![CDATA[Event sent by the robot when it detects an internal error.

 To receive over DES you have to subscribe to the CHANNEL for the event and then write a listener or a stream:

 monitor.subscribe(RobotError.CHANNEL); on all RobotError() as re { doSomething(); }]]></Description><Summary><![CDATA[Event sent by the robot when it detects an internal error.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="id" type="integer"><Description><![CDATA[ID of the robot]]></Description><Summary><![CDATA[ID of the robot]]></Summary><TypeParameters/></Member><Member name="message" type="string"><Description><![CDATA[Message describing the error.]]></Description><Summary><![CDATA[Message describing the error.]]></Summary><TypeParameters/></Member><Member constant="true" name="CHANNEL" type="string" typeValue="&quot;des:apamax.training.RobotError&quot;"><Description><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.

 Sending, subscribing and unsubscribing to this channel is no different than interacting with any other Apama channel. To get the Chain instance associated with sending or receiving of this type, use the com.softwareag.connectivity.ConnectivityPlugins.getChainByChannel action.

 Note: Events of this type cannot be sent or received reliably unless the com.softwareag.connectivity.MessageId annotation is used for them.]]></Description><Summary><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="RequestRobotStatus"><Description><![CDATA[Send this event for the robot manager to reply with the status of all the robots.

 To send to DES you have to send the event to the appropriate channel, for example::

 send RequestRobotStatus() to RequestRobotStatus.CHANNEL;

 This event has no members.]]></Description><Summary><![CDATA[Send this event for the robot manager to reply with the status of all the robots.]]></Summary><TypeParameters/><See package="apamax.training" type="RobotStatus"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member constant="true" name="CHANNEL" type="string" typeValue="&quot;des:apamax.training.RequestRobotStatus&quot;"><Description><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.

 Sending, subscribing and unsubscribing to this channel is no different than interacting with any other Apama channel. To get the Chain instance associated with sending or receiving of this type, use the com.softwareag.connectivity.ConnectivityPlugins.getChainByChannel action.

 Note: Events of this type cannot be sent or received reliably unless the com.softwareag.connectivity.MessageId annotation is used for them.]]></Description><Summary><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="Alert"><Description><![CDATA[Send an alert via DES to be diplayed on the alerts dashboard.

 To send to DES you have to send the event to the appropriate channel, for example:

 send Alert("YourNameHere", "Description of the alert") to Alert.CHANNEL;]]></Description><Summary><![CDATA[Send an alert via DES to be diplayed on the alerts dashboard.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="user" type="string"><Description><![CDATA[Name of the user sending the alert.]]></Description><Summary><![CDATA[Name of the user sending the alert.]]></Summary><TypeParameters/></Member><Member name="description" type="string"><Description><![CDATA[Description of the alert.]]></Description><Summary><![CDATA[Description of the alert.]]></Summary><TypeParameters/></Member><Member constant="true" name="CHANNEL" type="string" typeValue="&quot;des:apamax.training.Alert&quot;"><Description><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.

 Sending, subscribing and unsubscribing to this channel is no different than interacting with any other Apama channel. To get the Chain instance associated with sending or receiving of this type, use the com.softwareag.connectivity.ConnectivityPlugins.getChainByChannel action.

 Note: Events of this type cannot be sent or received reliably unless the com.softwareag.connectivity.MessageId annotation is used for them.]]></Description><Summary><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="RegisterRobot"><Description><![CDATA[This event is send by a robot which its (dynamically generated) ID when it starts up.

 To receive over DES you have to subscribe to the CHANNEL for the event and then write a listener or a stream:

 monitor.subscribe(RegisterRobot.CHANNEL); on all RegisterRobot() as rr { doSomething(); }]]></Description><Summary><![CDATA[This event is send by a robot which its (dynamically generated) ID when it starts up.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="id" type="integer"><Description><![CDATA[The unique ID of the robot]]></Description><Summary><![CDATA[The unique ID of the robot]]></Summary><TypeParameters/></Member><Member constant="true" name="CHANNEL" type="string" typeValue="&quot;des:apamax.training.RegisterRobot&quot;"><Description><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.

 Sending, subscribing and unsubscribing to this channel is no different than interacting with any other Apama channel. To get the Chain instance associated with sending or receiving of this type, use the com.softwareag.connectivity.ConnectivityPlugins.getChainByChannel action.

 Note: Events of this type cannot be sent or received reliably unless the com.softwareag.connectivity.MessageId annotation is used for them.]]></Description><Summary><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="RobotDataRequest"><Description><![CDATA[Request a summary of the current data of a given robot from the robot manager.

 To send to DES you have to send the event to the appropriate channel, for example:

 integer requestId := integer.MAX.rand(); send RobotDataRequest(robotId, requestId) to RobotDataRequest.CHANNEL;

 You should use the request ID when listening for the RobotDataSummary in response.]]></Description><Summary><![CDATA[Request a summary of the current data of a given robot from the robot manager.]]></Summary><TypeParameters/><See package="apamax.training" type="RobotDataSummary"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="id" type="integer"><Description><![CDATA[The Id of the robot you want the data for.]]></Description><Summary><![CDATA[The Id of the robot you want the data for.]]></Summary><TypeParameters/></Member><Member name="requestId" type="integer"><Description><![CDATA[A random request id to distinguish your requests from anyone else's. Will be included in the response.]]></Description><Summary><![CDATA[A random request id to distinguish your requests from anyone else's. Will be included in the response.]]></Summary><TypeParameters/></Member><Member constant="true" name="CHANNEL" type="string" typeValue="&quot;des:apamax.training.RobotDataRequest&quot;"><Description><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.

 Sending, subscribing and unsubscribing to this channel is no different than interacting with any other Apama channel. To get the Chain instance associated with sending or receiving of this type, use the com.softwareag.connectivity.ConnectivityPlugins.getChainByChannel action.

 Note: Events of this type cannot be sent or received reliably unless the com.softwareag.connectivity.MessageId annotation is used for them.]]></Description><Summary><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="RobotDataSummary"><Description><![CDATA[This event is returned in response to a RobotDataRequest and contains the current data of the robot.

 To receive over DES you have to subscribe to the CHANNEL for the event and then write a listener or a stream. The listener should include the requestId you sent with the request.

 monitor.subscribe(RobotDataSummary.CHANNEL); on all RobotDataSummary(requestId=requestId) as rds { doSomething(); }]]></Description><Summary><![CDATA[This event is returned in response to a RobotDataRequest and contains the current data of the robot.]]></Summary><TypeParameters/><See package="apamax.training" type="RobotDataRequest"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="id" type="integer"><Description><![CDATA[The ID of the robot we requested.]]></Description><Summary><![CDATA[The ID of the robot we requested.]]></Summary><TypeParameters/></Member><Member name="requestId" type="integer"><Description><![CDATA[The requestId which was provided in the request message.]]></Description><Summary><![CDATA[The requestId which was provided in the request message.]]></Summary><TypeParameters/></Member><Member name="temperature1" type="float"><Description><![CDATA[The temperature of sensor 1]]></Description><Summary><![CDATA[The temperature of sensor 1]]></Summary><TypeParameters/></Member><Member name="temperature2" type="float"><Description><![CDATA[The temperature of sensor 2]]></Description><Summary><![CDATA[The temperature of sensor 2]]></Summary><TypeParameters/></Member><Member constant="true" name="CHANNEL" type="string" typeValue="&quot;des:apamax.training.RobotDataSummary&quot;"><Description><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.

 Sending, subscribing and unsubscribing to this channel is no different than interacting with any other Apama channel. To get the Chain instance associated with sending or receiving of this type, use the com.softwareag.connectivity.ConnectivityPlugins.getChainByChannel action.

 Note: Events of this type cannot be sent or received reliably unless the com.softwareag.connectivity.MessageId annotation is used for them.]]></Description><Summary><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="TemperatureReading"><Description><![CDATA[Temperature readings taken periodically from the sensor on a robot. Will be sent periodically in normal running of the robot.

 To receive over DES you have to subscribe to the CHANNEL for the event and then write a listener or a stream:

 monitor.subscribe(TemperatureReading.CHANNEL); on all TemperatureReading() as tr { doSomething(); }]]></Description><Summary><![CDATA[Temperature readings taken periodically from the sensor on a robot. Will be sent periodically in normal running of the robot.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="id" type="integer"><Description><![CDATA[The unique ID of the robot.]]></Description><Summary><![CDATA[The unique ID of the robot.]]></Summary><TypeParameters/></Member><Member name="sensor" type="integer"><Description><![CDATA[The index of which sensor on the robot (1 or 2) was read.]]></Description><Summary><![CDATA[The index of which sensor on the robot (1 or 2) was read.]]></Summary><TypeParameters/></Member><Member name="temperature" type="float"><Description><![CDATA[The current temperature reading of the robot.]]></Description><Summary><![CDATA[The current temperature reading of the robot.]]></Summary><TypeParameters/></Member><Member constant="true" name="CHANNEL" type="string" typeValue="&quot;des:apamax.training.TemperatureReading&quot;"><Description><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.

 Sending, subscribing and unsubscribing to this channel is no different than interacting with any other Apama channel. To get the Chain instance associated with sending or receiving of this type, use the com.softwareag.connectivity.ConnectivityPlugins.getChainByChannel action.

 Note: Events of this type cannot be sent or received reliably unless the com.softwareag.connectivity.MessageId annotation is used for them.]]></Description><Summary><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="RobotSimulator" private="true"><Description><![CDATA[A class for simulating robot data.]]></Description><Summary><![CDATA[A class for simulating robot data.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="apamax.training" type="RegisterRobot"/><Reference package="apamax.training" type="RobotDataSummary"/><Reference package="apamax.training" type="RobotError"/><Reference package="apamax.training" type="TemperatureReading"/></Sends><Listens><Reference package="apamax.training" type="RobotDataRequest"/></Listens><Spawns/><Member name="temperatureRange" type="float"><TypeParameters/></Member><Member name="temperatureMean1" type="float"><TypeParameters/></Member><Member name="currentTemperature1" type="float"><TypeParameters/></Member><Member name="temperatureMean2" type="float"><TypeParameters/></Member><Member name="currentTemperature2" type="float"><TypeParameters/></Member><Member name="period" type="float"><TypeParameters/></Member><Member name="offset" type="float"><TypeParameters/></Member><Member name="error" type="boolean"><TypeParameters/></Member><Member name="onlySendOne" type="boolean"><TypeParameters/></Member><Member name="id" type="integer"><TypeParameters/></Member><Member name="simoutListener" type="listener"><TypeParameters/></Member><Action name="startSingleSensor" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="updateTemperature2" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="updateTemperature1" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="initDefaults" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="startSimulating" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="apamax.training" type="RegisterRobot"/><Reference package="apamax.training" type="RobotDataSummary"/><Reference package="apamax.training" type="TemperatureReading"/></Sends><Listens><Reference package="apamax.training" type="RobotDataRequest"/></Listens><Spawns/></Action><Action name="startStuckSensor" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="stuckAt" type="float"/></Parameters></Action><Action name="startSimulationWithErrors" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="apamax.training" type="RobotError"/></Sends><Listens/><Spawns/></Action><Action name="startSpikeySimulation" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="startSlowSimulation" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="startSplitTempSimulation" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="startNormalSimulation" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="startVariableSimulation" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="startDeadSimulation" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="apamax.training" type="RegisterRobot"/></Sends><Listens/><Spawns/></Action><Action name="startHotSimulation" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="startIncreasingSimulation" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action></Type><Type category="Event" name="RobotStatus"><Description><![CDATA[An event sent out by the robot manager whenever the status of a robot changes or in response to a RequestRobotStatus event.

 To receive over DES you have to subscribe to the CHANNEL for the event and then write a listener or a stream:

 monitor.subscribe(RobotStatus.CHANNEL); on all RobotStatus() as rs { doSomething(); }]]></Description><Summary><![CDATA[An event sent out by the robot manager whenever the status of a robot changes or in response to a RequestRobotStatus event.]]></Summary><TypeParameters/><See package="apamax.training" type="RequestRobotStatus"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="id" type="integer"><Description><![CDATA[The ID of the robot.]]></Description><Summary><![CDATA[The ID of the robot.]]></Summary><TypeParameters/></Member><Member name="status" type="string"><Description><![CDATA[The current status of the robot - OK or an error message.]]></Description><Summary><![CDATA[The current status of the robot - OK or an error message.]]></Summary><TypeParameters/></Member><Member constant="true" name="CHANNEL" type="string" typeValue="&quot;des:apamax.training.RobotStatus&quot;"><Description><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.

 Sending, subscribing and unsubscribing to this channel is no different than interacting with any other Apama channel. To get the Chain instance associated with sending or receiving of this type, use the com.softwareag.connectivity.ConnectivityPlugins.getChainByChannel action.

 Note: Events of this type cannot be sent or received reliably unless the com.softwareag.connectivity.MessageId annotation is used for them.]]></Description><Summary><![CDATA[The Apama channel associated with this event type. This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.]]></Summary><TypeParameters/></Member></Type><Type category="Monitor" name="TrainingSimulator" private="true"><Description><![CDATA[This monitor generates all the simulation data for the training.]]></Description><Summary><![CDATA[This monitor generates all the simulation data for the training.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/></Type></Package><Package depth="../../../" display="com.softwareag.connectivity" name="com.softwareag.connectivity"><Type category="Event" name="Chain"><Description><![CDATA[Represents a chain instance and provides methods to perform various operations on it.]]></Description><Summary><![CDATA[Represents a chain instance and provides methods to perform various operations on it.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Import library="ConnectivityPlugin" name="_plugin" private="true"><Description/><Summary/><TypeParameters/></Import><Member name="chain" private="true" type="chunk"><Description/><Summary/><TypeParameters/></Member><Action name="flush" staticNature=""><Description><![CDATA[Ask the chain to acknowledge all events previously sent to it by the application. A FlushAck reply will be sent to the current context once these events have been reliably processed by the external system.

 This action will only have an effect on chains with a reliable-messaging-aware transport, and should not be used otherwise.

 A transport will still handle events that are sent to it, whether or not flushing is used. A flush request is purely a signalling mechanism.]]></Description><Summary><![CDATA[Ask the chain to acknowledge all events previously sent to it by the application. A FlushAck reply will be sent to the current context once these events have been reliably processed by the external system.]]></Summary><TypeParameters/><See package="com.softwareag.connectivity.control" type="FlushAck"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The requestId of the expected FlushAck]]></Description></Returns></Action><Action name="ackUpTo" staticNature=""><Description><![CDATA[Acknowledge that a specific event and all previous events received from this connectivity chain have been reliably processed by your application.

 If you are going to make use of this action, then the message id of the incoming events will need to be available somehow. For example, as a field on the event.

 This action will only have an effect on chains with a reliable-messaging-aware transport, and should not be used otherwise.]]></Description><Summary><![CDATA[Acknowledge that a specific event and all previous events received from this connectivity chain have been reliably processed by your application.]]></Summary><TypeParameters/><See package="com.softwareag.connectivity.control" type="AckRequired"><Description><![CDATA[In some situations it may make more sense to do acknowledgments on AckRequired requests, rather than against events of the application's choice.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="messageId" type="string"><Description><![CDATA[The message id of the specific event]]></Description></Parameter></Parameters></Action><Action name="destroy" staticNature=""><Description><![CDATA[Destroy this chain instance. Chains that are managed by a dynamic chain manager cannot be destroyed this way. This should be called only once.]]></Description><Summary><![CDATA[Destroy this chain instance. Chains that are managed by a dynamic chain manager cannot be destroyed this way. This should be called only once.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="getId" staticNature=""><Description><![CDATA[Return the unique id of the chain instance.]]></Description><Summary><![CDATA[Return the unique id of the chain instance.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"><Description><![CDATA[The id of the chain instance]]></Description></Returns></Action></Type><Type category="Event" name="ConnectivityPlugins"><Description><![CDATA[Utilities for interacting with connectivity plug-ins.]]></Description><Summary><![CDATA[Utilities for interacting with connectivity plug-ins.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Import library="ConnectivityPlugin" name="_plugin" private="true"><Description/><Summary/><TypeParameters/></Import><Action name="createChain" staticNature="static "><Description><![CDATA[Create and start a chain instance from the given chain definition listed in dynamicChains in the configuration file.

 This action returns a Chain that has already been created and started. It is immediately able to receive events.]]></Description><Summary><![CDATA[Create and start a chain instance from the given chain definition listed in dynamicChains in the configuration file.]]></Summary><Deprecated><Description><![CDATA[[This action has been deprecated. Please use createDynamicChain instead.]]]></Description><Summary><![CDATA[[This action has been deprecated. Please use createDynamicChain instead.]]]></Summary></Deprecated><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns package="com.softwareag.connectivity" type="Chain"><Description><![CDATA[A Chain object which can be used to destroy this chain later]]></Description></Returns><Parameters><Parameter name="chainInstanceId" type="string"><Description><![CDATA[The unique identifier to use for the new chain instance. This identifier is used for logging, and for looking up existing Chain objects by id. Caution: A small amount of memory is allocated for each unique chain instance identifier. This memory is not freed when the chain is destroyed. Therefore, if you are creating many chains, consider reusing old chain instance identifiers. If you create more than 1000 unique identifiers, a warning is written to the correlator log file to notify you of this. You cannot have two active chains with the same chain instance identifier, so only reuse identifiers which are no longer in use.]]></Description></Parameter><Parameter name="channels" type="sequence"><Parameters><Parameter type="string"/></Parameters><Description><![CDATA[The list of channels this chain should subscribe to]]></Description></Parameter><Parameter name="chainDefnName" type="string"><Description><![CDATA[The name of a chain definition listed under dynamicChains in the configuration file]]></Description></Parameter><Parameter name="substitutions" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters><Description><![CDATA[Dictionary providing values for <code>@{...}</code> dynamic substitution variables in the chain definition]]></Description></Parameter></Parameters></Action><Action name="onApplicationInitialized" staticNature="static "><Description><![CDATA[Should be called by EPL applications after all EPL has been injected and initialized, to indicate that the application is ready to receive events from connectivity plug-ins.

 This will also enable reception of JMS events if correlator-integrated JMS is enabled (That is, it implicitly calls JMSPlugin.onApplicationInitialized)

 Invoking this action more than once is an error and will throw an exception.]]></Description><Summary><![CDATA[Should be called by EPL applications after all EPL has been injected and initialized, to indicate that the application is ready to receive events from connectivity plug-ins.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="getChainById" staticNature="static "><Description><![CDATA[Look up a chain instance by its identifier. This can retrieve dynamically created chains, as well as statically created chains from 'startChains' in the correlator configuration.

 An exception is thrown if no chain exists with this identifier.]]></Description><Summary><![CDATA[Look up a chain instance by its identifier. This can retrieve dynamically created chains, as well as statically created chains from 'startChains' in the correlator configuration.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns package="com.softwareag.connectivity" type="Chain"><Description><![CDATA[The chain instance]]></Description></Returns><Parameters><Parameter name="chainInstanceId" type="string"><Description><![CDATA[The unique identifier of the chain instance]]></Description></Parameter></Parameters></Action><Action name="getChainByChannel" staticNature="static "><Description><![CDATA[Look up a chain instance by a channel it is subscribed to or sending to.

 There must be exactly one chain matching the requested combination of channel and direction, else an exception is thrown.

 The direction of the channel specifies how the channel is used by the chain instance. The TOWARDS_TRANSPORT direction means that the channel is one of the channels that the chain instance is subscribed to to receive events from the host. The TOWARDS_HOST direction means that the channel is used by the chain instance as the default channel to deliver events from the transport to the host.]]></Description><Summary><![CDATA[Look up a chain instance by a channel it is subscribed to or sending to.]]></Summary><TypeParameters/><See package="com.softwareag.connectivity" type="Direction"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns package="com.softwareag.connectivity" type="Chain"/><Parameters><Parameter name="channel" type="string"><Description><![CDATA[The channel to use for lookup.]]></Description></Parameter><Parameter name="direction" type="string"><Description><![CDATA[Specifies the direction in which the channel is used by the chain instance. Use the constants defined in the Direction event for string literals.]]></Description></Parameter></Parameters></Action><Action name="createDynamicChain" staticNature="static "><Description><![CDATA[Create and start a chain instance from the given chain definition listed in dynamicChains in the configuration file.

 This action returns a Chain that has already been created and started. It is immediately able to receive events.]]></Description><Summary><![CDATA[Create and start a chain instance from the given chain definition listed in dynamicChains in the configuration file.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns package="com.softwareag.connectivity" type="Chain"><Description><![CDATA[A Chain object which can be used to destroy this chain later]]></Description></Returns><Parameters><Parameter name="chainInstanceId" type="string"><Description><![CDATA[The unique identifier to use for the new chain instance. This identifier is used for logging, and for looking up existing Chain objects by id.]]></Description></Parameter><Parameter name="channels" type="sequence"><Parameters><Parameter type="string"/></Parameters><Description><![CDATA[The list of channels this chain should subscribe to]]></Description></Parameter><Parameter name="chainDefnName" type="string"><Description><![CDATA[The name of a chain definition listed under dynamicChains in the configuration file]]></Description></Parameter><Parameter name="substitutions" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters><Description><![CDATA[Dictionary providing values for <code>@{...}</code> dynamic substitution variables in the chain definition]]></Description></Parameter><Parameter name="defaultChannelTowardsHost" type="string"><Description><![CDATA[Default channel to use for sending a message towards the host if no channel is specified on the message. Use an empty string for no default channel. It is an error to specify non-empty defaultChannelTowardsHost value if defaultChannel is also specified for the host plug-in.]]></Description></Parameter></Parameters></Action></Type><Type category="Event" name="Direction"><Description><![CDATA[Utility event to provide string literals for direction.]]></Description><Summary><![CDATA[Utility event to provide string literals for direction.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member constant="true" name="TOWARDS_TRANSPORT" type="string" typeValue="&quot;TOWARDS_TRANSPORT&quot;"><Description><![CDATA[The direction of messages flowing towards the transport (from the host).]]></Description><Summary><![CDATA[The direction of messages flowing towards the transport (from the host).]]></Summary><TypeParameters/></Member><Member constant="true" name="TOWARDS_HOST" type="string" typeValue="&quot;TOWARDS_HOST&quot;"><Description><![CDATA[The direction of messages flowing towards the host (from the transport).]]></Description><Summary><![CDATA[The direction of messages flowing towards the host (from the transport).]]></Summary><TypeParameters/></Member></Type></Package><Package depth="../../../" display="com.apama.memorystore" name="com.apama.memorystore"><Type category="Event" name="Finished"><Description><![CDATA[Sent to the application when an asynchronous activity has finished.]]></Description><Summary><![CDATA[Sent to the application when an asynchronous activity has finished.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="id" type="integer"><Description><![CDATA[A unique identifier for the operation that has completed, which will have been returned by the action that initiated the operation.]]></Description><Summary><![CDATA[A unique identifier for the operation that has completed, which will have been returned by the action that initiated the operation.]]></Summary><TypeParameters/></Member><Member name="success" type="boolean"><Description><![CDATA[True if the operation succeeded.]]></Description><Summary><![CDATA[True if the operation succeeded.]]></Summary><TypeParameters/></Member><Member name="status" type="string"><Description><![CDATA[An optional status or error message providing more detail about why the operation succeeded or failed.]]></Description><Summary><![CDATA[An optional status or error message providing more detail about why the operation succeeded or failed.]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="Storage"><Description><![CDATA[MemoryStore factory interface for creating Store event objects.

 There are several different types of Store supported by MemoryStore: <ul> <li>In-memory only (no persistence)</li> <li>Persistent (using a specified database file on disk; committed changes go to disk when the persist() action is called)</li> <li>Correlator-persistent (using the Correlator's integrated data store; committed changes go to disk periodically when the Correlator takes a snapshot of persistent monitor state and persists the results). </li> <li>Distributed (Using a distributed cache technology to share and access data across multiple distributed nodes). </li> </ul> Correlator-persistent stores are only available if Correlator persistence has been enabled. Non-persistent monitors may use any type of store, but a monitor marked as 'persistent' may ONLY access Correlator-persistent stores.

 To use the MemoryStore, create a monitor field (or variable) to hold the Storage factory event, and use one of the prepare* actions to asynchronously get a Store of the desired type ready for use, and give it a unique name. Once the store has been prepared, use the open(name) action to get a Store event that can be used to interact with the store.

 e.g.<pre> <br/>using com.apama.memorystore.Storage; <br/>using com.apama.memorystore.Store; <br/>using com.apama.memorystore.Finished; <br/> <br/>monitor Test { <br/>	Storage storage; <br/>	Store store; <br/> <br/>	action onload() { <br/>		integer id := storage.prepareOrCreate("storename", "/tmp/example.dat"); <br/>		Finished f; <br/>		on Finished(id=id):f <br/>		{ <br/>			if not f.success { log "Store creation failed: "+f.status at ERROR; die; } <br/>			store := storage.open("storename"); <br/>			... <br/>		} <br/>	} <br/>} </pre>]]></Description><Summary><![CDATA[MemoryStore factory interface for creating Store event objects.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Store"><Description><![CDATA[The purpose of the Storage event is to prepare and open stores.]]></Description></See><See action="prepareOrCreate" package="com.apama.memorystore" type="Storage"><Description><![CDATA[The most commonly used action for preparing a persistent Store.]]></Description></See><See action="open" package="com.apama.memorystore" type="Storage"><Description><![CDATA[Once a store has been prepared it can be opened.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Import library="MemoryStorePlugin" name="plugin" private="true"><Description/><Summary/><TypeParameters/></Import><Action name="prepare" staticNature="static "><Description><![CDATA[Prepare a persistent read-write Store associated with an existing database file on disk.

 The specified file must exist and must have been created by the MemoryStore. If the specified file does not exist, or cannot be opened for read-write, the Finished event will indicate failure.]]></Description><Summary><![CDATA[Prepare a persistent read-write Store associated with an existing database file on disk.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete and it becomes safe to call open() on this store.]]></Description></Returns><Parameters><Parameter name="name" type="string"><Description><![CDATA[A unique name identifying this Store.]]></Description></Parameter><Parameter name="filename" type="string"><Description><![CDATA[The path of the database file holding the persistent store. If a relative path is specified, it is relative to the directory that contains the associated Apama Studio project (i.e. the Correlator working directory).]]></Description></Parameter></Parameters></Action><Action name="prepareDistributed" staticNature="static "><Description><![CDATA[Prepare a distributed store (e.g. distributed cache) to be opened and used by the application.]]></Description><Summary><![CDATA[Prepare a distributed store (e.g. distributed cache) to be opened and used by the application.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete and it becomes safe to call open() on this store.]]></Description></Returns><Parameters><Parameter name="name" type="string"><Description><![CDATA[A unique name identifying this Store, which also specifies the id of its configuration bean in the XML configuration file. This name should not contain spaces.]]></Description></Parameter></Parameters></Action><Action name="prepareCorrelatorPersistent" staticNature="static "><Description><![CDATA[Prepare a Correlator-persistent read-write Store to be opened and used by the application.

 All committed changes made to a Correlator-persistent store are persisted to disk automatically whenever the Correlator takes a snapshot of the Correlator persistent application state. Because the Correlator determines when to persist its state, you cannot explicitly request persistence for a Correlator-persistent store or any tables it contains.

 Attempts to create a Correlator-persistent store in a Correlator that does not have persistence enabled will result in an error that will terminate the monitor instance.]]></Description><Summary><![CDATA[Prepare a Correlator-persistent read-write Store to be opened and used by the application.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete and it becomes safe to call open() on this store.]]></Description></Returns><Parameters><Parameter name="name" type="string"><Description><![CDATA[A unique name identifying this Store.]]></Description></Parameter></Parameters></Action><Action name="prepareOrCreate" staticNature="static "><Description><![CDATA[Prepare a persistent read-write Store associated with a database file on disk, which will be created if it does not exist already.]]></Description><Summary><![CDATA[Prepare a persistent read-write Store associated with a database file on disk, which will be created if it does not exist already.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete and it becomes safe to call open() on this store.]]></Description></Returns><Parameters><Parameter name="name" type="string"><Description><![CDATA[A unique name identifying this Store.]]></Description></Parameter><Parameter name="filename" type="string"><Description><![CDATA[The path of the database file holding the persistent store. If a relative path is specified, it is relative to the directory that contains the associated Apama Studio project (i.e. the Correlator working directory). The parent directory of the specified file must already exist.]]></Description></Parameter></Parameters></Action><Action name="prepareReadOnly" staticNature="static "><Description><![CDATA[Prepare a persistent read-only Store associated with an existing database file on disk.]]></Description><Summary><![CDATA[Prepare a persistent read-only Store associated with an existing database file on disk.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete and it becomes safe to call open() on this store.]]></Description></Returns><Parameters><Parameter name="name" type="string"><Description><![CDATA[A unique name identifying this Store.]]></Description></Parameter><Parameter name="filename" type="string"><Description><![CDATA[The path of the database file holding the persistent store. If a relative path is specified, it is relative to the directory that contains the associated Apama Studio project (i.e. the Correlator working directory).]]></Description></Parameter></Parameters></Action><Action name="hasDistributedStore" staticNature="static "><Description><![CDATA[Indicates whether configuration for the given distributed store name exists.

 Returning false indicates that a prepareDistributed of the store name will definitely fail.  True indicates it may succeed, but is not a guarantee of success. Does not actually connect to the distributed store.]]></Description><Summary><![CDATA[Indicates whether configuration for the given distributed store name exists.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"><Description><![CDATA[false if prepareDistributed for the given store name will definitely fail]]></Description></Returns><Parameters><Parameter name="name" type="string"/></Parameters></Action><Action name="hasStore" staticNature="static "><Description><![CDATA[Indicate whether or not a Store with the specified name has been prepared already.]]></Description><Summary><![CDATA[Indicate whether or not a Store with the specified name has been prepared already.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"><Description><![CDATA[True if it is safe to call open() on the specified store; false if preparation failed or is still in progress.]]></Description></Returns><Parameters><Parameter name="name" type="string"><Description><![CDATA[A unique name identifying this Store.]]></Description></Parameter></Parameters></Action><Action name="prepareInMemory" staticNature="static "><Description><![CDATA[Prepare an in-memory read-write Store to be opened and used by the application.]]></Description><Summary><![CDATA[Prepare an in-memory read-write Store to be opened and used by the application.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete and it becomes safe to call open() on this store.]]></Description></Returns><Parameters><Parameter name="name" type="string"><Description><![CDATA[A unique name identifying this Store.]]></Description></Parameter></Parameters></Action><Action name="open" staticNature="static "><Description><![CDATA[Open a named Store that has already been prepared, ready for use by this monitor instance.

 Every monitor instance should prepare and open the stores it needs. Multiple monitor instances can have the same table open at the same time.

 It is an error to call open() before a prepare call for the table has finished without error.

 Note that opening a store will not immediately bring all that store's tables into memory, this only happens when each individual table is itself prepared and opened.

 A persistent monitor can access only Correlator-persistent stores. If a persistent monitor tries to open any other type of store (e.g. in-memory, on-disk or distributed) the monitor instance will terminate with an error.]]></Description><Summary><![CDATA[Open a named Store that has already been prepared, ready for use by this monitor instance.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns package="com.apama.memorystore" type="Store"/><Parameters><Parameter name="name" type="string"><Description><![CDATA[A unique name identifying this Store.]]></Description></Parameter></Parameters></Action></Type><Type category="Event" name="Table"><Description><![CDATA[Represents a collection of rows in a store, with a defined schema.

 A table consists of a series of rows, each identified by a key and containing other values with names and types according to the table's Schema.

 A table typically resides in memory, you can also store it on disk if you want to, or a table can be stored on a distributed cache.]]></Description><Summary><![CDATA[Represents a collection of rows in a store, with a defined schema.]]></Summary><TypeParameters/><See action="open" package="com.apama.memorystore" type="Store"><Description><![CDATA[Tables exist within a named Store, which is used to create and open tables.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Import library="MemoryStorePlugin" name="plugin" private="true"><Description/><Summary/><TypeParameters/></Import><Member name="c" private="true" type="chunk" wildcard="true"><Description/><Summary/><TypeParameters/></Member><Action name="add" staticNature=""><Description><![CDATA[Add the table Row with the specified key.

 On distributed stores, for performance reasons this action doesn't check if there is a Row already present in the the table with the specified key. To check if the Row is present in the store, use the Table.get() action.]]></Description><Summary><![CDATA[Add the table Row with the specified key.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns package="com.apama.memorystore" type="Row"><Description><![CDATA[An empty Row event.]]></Description></Returns><Parameters><Parameter name="key" type="string"><Description><![CDATA[The name/key uniquely identifying the row.]]></Description></Parameter></Parameters></Action><Action name="mutate" staticNature=""><Description><![CDATA[Change the row with the specified key by applying an action to it.

 It is possible for another context to commit changes to this row between the time mutate() obtains a Row event to represent the row and the time mutate() tries to commit the changes that result from executing the specified action. In this situation, the MemoryStore automatically calls the specified action again on the most recently committed row content; therefore mutation actions must be designed to cope with being called repeatedly without causing unwanted side effects.]]></Description><Summary><![CDATA[Change the row with the specified key by applying an action to it.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="key" type="string"/><Parameter name="a" type="action"><Parameters><Parameter package="com.apama.memorystore" type="Row"/></Parameters><Description><![CDATA[An action that (idempotently) performs the desired change to the row.]]></Description></Parameter></Parameters></Action><Action name="hasKey" staticNature=""><Description><![CDATA[Indicate whether or not a row with the specified key is present in the table.

 t.hasKey("foo") is a more efficient alternative to t.get("foo").inTable()]]></Description><Summary><![CDATA[Indicate whether or not a row with the specified key is present in the table.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/><Parameters><Parameter name="key" type="string"><Description><![CDATA[The name/key uniquely identifying the row.]]></Description></Parameter></Parameters></Action><Action name="getTableName" staticNature=""><Description><![CDATA[Get the name of this Table.]]></Description><Summary><![CDATA[Get the name of this Table.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/></Action><Action name="getFieldIndex" staticNature=""><Description><![CDATA[Return the index of a field.

 Returns what position in the Schema the specified field appears at. If a name that is not in Schema fieldName is passed in, the monitor instance will be terminated with an error.

 Using this action is more efficient that getting the same information by using indexOf on the Schema.fields sequence.]]></Description><Summary><![CDATA[Return the index of a field.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"/><Parameters><Parameter name="fieldName" type="string"><Description><![CDATA[A field name that exists in this table's Schema.]]></Description></Parameter></Parameters></Action><Action name="clear" staticNature=""><Description><![CDATA[Remove all rows from the table.]]></Description><Summary><![CDATA[Remove all rows from the table.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="getKeys" staticNature=""><Description><![CDATA[Returns a sequence that contains the keys for all the rows in this table.

 The keys are in an arbitrary order.]]></Description><Summary><![CDATA[Returns a sequence that contains the keys for all the rows in this table.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="sequence"><Parameters><Parameter type="string"/></Parameters></Returns></Action><Action name="mutateAll" staticNature=""><Description><![CDATA[Mutate all rows in the Table by applying the specified action.

 This can temporarily consume a lot of memory when called on a relatively large table because the Correlator does no garbage collection until action execution is complete. A few thousand rows are unlikely to present a problem. Beyond that, it depends on how many fields are in each row, how many rows are in the table, and how much RAM is available.]]></Description><Summary><![CDATA[Mutate all rows in the Table by applying the specified action.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="a" type="action"><Parameters><Parameter package="com.apama.memorystore" type="Row"/></Parameters><Description><![CDATA[An action that performs the desired change to each row in the table.]]></Description></Parameter></Parameters></Action><Action name="remove" staticNature=""><Description><![CDATA[Remove the specified row from the table.

 If the row does not exist, this action does nothing.]]></Description><Summary><![CDATA[Remove the specified row from the table.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="key" type="string"><Description><![CDATA[The name/key uniquely identifying the row.]]></Description></Parameter></Parameters></Action><Action name="enqueueColumn" staticNature=""><Description><![CDATA[Enqueue an event for each row in the table, taken by parsing the string data in the specified table field/column as an event string.

 The field must be of string type, and its value for every row should be an Apama event string, in the same form that you would send to the Correlator (e.g. "mypackage.MyEvent(123, [false,true])")

 This action is most likely to be useful when you are migrating from the StateStore Correlator plug-in to the MemoryStore. In the StateStore plug-in, persistent data re-entered the Correlator as sent events.

 This is only supported for non-distributed stores.]]></Description><Summary><![CDATA[Enqueue an event for each row in the table, taken by parsing the string data in the specified table field/column as an event string.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the column data for the last row has been sent.]]></Description></Returns><Parameters><Parameter name="fieldName" type="string"><Description><![CDATA[The name of the table field whose values are event strings that should be sent.]]></Description></Parameter></Parameters></Action><Action name="getStoreName" staticNature=""><Description><![CDATA[Get the name of the Store that contains this table.]]></Description><Summary><![CDATA[Get the name of the Store that contains this table.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/></Action><Action name="unsubscribe" staticNature=""><Description><![CDATA[Cancel a previous subscription.

 This is only supported for tables in a distributed store.

 If other monitors in this context have also subscribed, events will still be delivered until they have all unsubscribed. subscriptionId must be a value returned from a subscribeRowChanged() on this table.]]></Description><Summary><![CDATA[Cancel a previous subscription.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="subscriptionId" type="integer"><Description><![CDATA[Identifier for the subscription to remove, returned by subscribeRowChanged().]]></Description></Parameter></Parameters></Action><Action name="get" staticNature=""><Description><![CDATA[Get the table Row with the specified key.

 If there is no row with the specified key, this action returns without error, with a Row event that contains default values for the fields in the row. A call to the Row.inTable() action returns false.]]></Description><Summary><![CDATA[Get the table Row with the specified key.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns package="com.apama.memorystore" type="Row"><Description><![CDATA[A Row event representing an atomic snapshot of the committed data in the table when the action was called.]]></Description></Returns><Parameters><Parameter name="key" type="string"><Description><![CDATA[The name/key uniquely identifying the row.]]></Description></Parameter></Parameters></Action><Action name="subscribeRowChanged" staticNature=""><Description><![CDATA[Subscribe to be notified of all successful commits in this table.

 This is only supported for tables in a distributed store, and only if the underlying provider supports this feature.

 The monitor instance will be terminated with an error if this action is called on a store that does not support it.

 It is important to note that (due to the nature of distributed store technology) there is no way to atomically subscribe to notifications and get an initial snapshot of the table's contents, so applications that perform an initial iteration over the table's contents to initialize some state before subscribing are at risk of double-counting any keys that are mutated after the subscription and during the iteration/initialization process.

 For tables that are relatively small (and fit entirely inside the memory of a single Correlator), a common pattern for addressing the need for a table snapshot to initialize state before subscribing is to maintain a per-key dictionary of last-seen values, updated by both the initial iteration and the RowChanged notification events; any RowChanged event whose old value does not match the last-seen dictionary must be ignored, to avoid double-counting changes. To save memory, entries from the last-seen dictionary can be removed after the first RowChanged event for that key.

 For distributed stores and drivers that support it, the application may also receive MissedRowChanges events to signify that some unknown number of updates have been missed (typically due to a network disconnection between the client and the store)]]></Description><Summary><![CDATA[Subscribe to be notified of all successful commits in this table.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="RowChanged"><Description><![CDATA[The event sent whenever a row is modified.]]></Description></See><See package="com.apama.memorystore" type="MissedRowChanges"><Description><![CDATA[The event sent whenever a row is modified.]]></Description></See><See action="unsubscribe" package="com.apama.memorystore" type="Table"><Description><![CDATA[Unsubscribe using this action.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[A unique subscriptionId that can be passed to any instance of this Table to unsubscribe.]]></Description></Returns></Action><Action name="persist" staticNature=""><Description><![CDATA[Persist this table's committed changes back to stable storage, asynchronously.

 Note that any local changes to a Row that were not committed will not be written to disk (see Row#commit()).

 Only on-disk persistent stores can be persisted using this action. It is not possible to call this method on Correlator-persistent tables since all changes committed to such tables will be written to disk automatically in the same transaction as changes to the state of persistent EPL monitors.]]></Description><Summary><![CDATA[Persist this table's committed changes back to stable storage, asynchronously.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete.]]></Description></Returns></Action><Action name="begin" staticNature=""><Description><![CDATA[Return an iterator to the beginning of the Table.]]></Description><Summary><![CDATA[Return an iterator to the beginning of the Table.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns package="com.apama.memorystore" type="Iterator"/></Action></Type><Type category="Event" name="Schema"><Description><![CDATA[Represents the schema for a table in the store, specifying the field names, types, and other behavioural information about the table.

 The fields and types sequences must be the same length as one another, specifying the names of fields and their corresponding types.

 Never construct a Schema using a "Schema(...)" expression. Instead, always create a variable initialized to "new Schema", and then set parameters individually with separate statements. This ensures that your code will continue to work without modification if a subsequent version of the MemoryStore adds more parameters to the Schema event.]]></Description><Summary><![CDATA[Represents the schema for a table in the store, specifying the field names, types, and other behavioural information about the table.]]></Summary><TypeParameters/><See action="prepare" package="com.apama.memorystore" type="Store"><Description><![CDATA[The schema for a table is specified when it is prepared.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="fields" type="sequence" wildcard="true"><Parameters><Parameter type="string"/></Parameters><Description><![CDATA[A sequence specifying the name of each field in this table.

 For looking up the index of a specific field name (e.g. while processing RowChanged events), use Table.getFieldIndex() which is more efficient than using indexOf() on the fields sequence.]]></Description><Summary><![CDATA[A sequence specifying the name of each field in this table.]]></Summary><TypeParameters/><See action="getFieldIndex" package="com.apama.memorystore" type="Table"><Description><![CDATA[for efficiently obtaining the index of a field.]]></Description></See></Member><Member name="types" type="sequence" wildcard="true"><Parameters><Parameter type="string"/></Parameters><Description><![CDATA[A sequence specifying the type of each field in this table.

 Permitted types are currently: 'integer', 'boolean', 'float', 'string' and 'decimal'.

 This sequence must have the same length as the fields sequence.]]></Description><Summary><![CDATA[A sequence specifying the type of each field in this table.]]></Summary><TypeParameters/></Member><Member name="exposeMemoryView" type="boolean"><Description><![CDATA[When this field is true, the MemoryStore makes the rows in the in-memory table associated with this schema available to the scenario service, so they can be used by external clients and dashboards.

 That is, the MemoryStore creates DataViews that contain the state of this table that has been committed (but not necessarily persisted) to the shared in-memory representation of the table.

 Committing changes to the in-memory row in a table that is exposing its in-memory state causes events to be sent to the main context.]]></Description><Summary><![CDATA[When this field is true, the MemoryStore makes the rows in the in-memory table associated with this schema available to the scenario service, so they can be used by external clients and dashboards.]]></Summary><TypeParameters/></Member><Member name="exposePersistentView" type="boolean"><Description><![CDATA[When this field is true, the MemoryStore makes the rows in the on-disk table associated with this schema available to the scenario service, so they can be used by external clients and dashboards.

 That is, the MemoryStore creates DataViews that contain data from this table that has been persisted to disk.

 You cannot expose a persistent view of a table in a correlator-persistent store.]]></Description><Summary><![CDATA[When this field is true, the MemoryStore makes the rows in the on-disk table associated with this schema available to the scenario service, so they can be used by external clients and dashboards.]]></Summary><TypeParameters/></Member><Member name="memoryViewDisplayName" type="string"><Description><![CDATA[Specifies the display name for an in-memory table.]]></Description><Summary><![CDATA[Specifies the display name for an in-memory table.]]></Summary><TypeParameters/></Member><Member name="memoryViewDescription" type="string"><Description><![CDATA[Describes an in-memory table.]]></Description><Summary><![CDATA[Describes an in-memory table.]]></Summary><TypeParameters/></Member><Member name="persistentViewDisplayName" type="string"><Description><![CDATA[Specifies the display name for an on-disk table.]]></Description><Summary><![CDATA[Specifies the display name for an on-disk table.]]></Summary><TypeParameters/></Member><Member name="persistentViewDescription" type="string"><Description><![CDATA[Describes an on-disk table.]]></Description><Summary><![CDATA[Describes an on-disk table.]]></Summary><TypeParameters/></Member><Action name="schemaFromAny" staticNature="static "><Description><![CDATA[Convert the supplied types into a valid MemoryStore table Schema.

 Field types that are not supported by MemoryStore are converted to strings.]]></Description><Summary><![CDATA[Convert the supplied types into a valid MemoryStore table Schema.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Returns package="com.apama.memorystore" type="Schema"><Description><![CDATA[The MemoryStore table Schema.]]></Description></Returns><Parameters><Parameter name="prototype" type="any"/></Parameters></Action><Action name="normalizeTypes" staticNature="static "><Description><![CDATA[Normalize a sequence of types to those accepted by Memory Store.

 Converts anything other than integer, float, boolean and decimal to string.]]></Description><Summary><![CDATA[Normalize a sequence of types to those accepted by Memory Store.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Returns type="sequence"><Parameters><Parameter type="string"/></Parameters><Description><![CDATA[Sequence of normalized string types]]></Description></Returns><Parameters><Parameter name="types" type="sequence"><Parameters><Parameter type="string"/></Parameters><Description><![CDATA[Type string sequence to normalize]]></Description></Parameter></Parameters></Action></Type><Type category="Event" name="Iterator"><Description><![CDATA[Represents an iterator that can be used to step through each Row of a Table in turn, making changes or reading data from the row.]]></Description><Summary><![CDATA[Represents an iterator that can be used to step through each Row of a Table in turn, making changes or reading data from the row.]]></Summary><TypeParameters/><See action="begin" package="com.apama.memorystore" type="Table"><Description><![CDATA[Gets an iterator, beginning from the start of the table.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Import library="MemoryStorePlugin" name="plugin" private="true"><Description/><Summary/><TypeParameters/></Import><Member name="c" private="true" type="chunk" wildcard="true"><Description/><Summary/><TypeParameters/></Member><Action name="getKey" staticNature=""><Description><![CDATA[Get the key for the row this Iterator is pointing at.

 To avoid an error that will terminate the monitor instance, always use done() to check that the iterator has not reached the end of the table before calling this action.]]></Description><Summary><![CDATA[Get the key for the row this Iterator is pointing at.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/></Action><Action name="appendKeys" staticNature=""><Description><![CDATA[Append to the specified sequence, keys for up to n consecutive rows of the Table, beginning where this Iterator is pointing.

 The iterator will be advanced. If it becomes done then fewer than n keys will be appended.]]></Description><Summary><![CDATA[Append to the specified sequence, keys for up to n consecutive rows of the Table, beginning where this Iterator is pointing.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="seq" type="sequence"><Parameters><Parameter type="string"/></Parameters><Description><![CDATA[The sequence which is to be updated with the keys from the following n table rows.]]></Description></Parameter><Parameter name="n" type="integer"><Description><![CDATA[The number of keys to get and append to the sequence.]]></Description></Parameter></Parameters></Action><Action name="step" staticNature=""><Description><![CDATA[Step this Iterator to the next row in the table.

 If there are no more rows the Iterator becomes done.

 To avoid an error that will terminate the monitor instance, always use done() to check that the iterator has not reached the end of the table before calling this action.]]></Description><Summary><![CDATA[Step this Iterator to the next row in the table.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="getKeys" staticNature=""><Description><![CDATA[Get the keys for up to n consecutive rows of the Table beginning where this Iterator is pointing.

 The iterator will be advanced. If it becomes done, a sequence of fewer than n keys will be returned.

 The first key in the returned sequence is the key of the row that the iterator is pointing at when the action is called. When this action is finished, the iterator is pointing at the row immediately beyond that of the last key that was returned.]]></Description><Summary><![CDATA[Get the keys for up to n consecutive rows of the Table beginning where this Iterator is pointing.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="sequence"><Parameters><Parameter type="string"/></Parameters></Returns><Parameters><Parameter name="n" type="integer"><Description><![CDATA[The number of keys to get and append to the sequence.]]></Description></Parameter></Parameters></Action><Action name="getRow" staticNature=""><Description><![CDATA[Get the Row this Iterator is pointing at.

 It is possible that the row the iterator is pointing at is no longer present. This can happen if another monitor deleted the row or table, or cleared the table while the iterator was pointing at that row.

 If the requested row is no longer there, you receive a Row event that represents a row in which all fields have default values and for which Row.inTable() is false. This is the same result as if you call Table.get() on a key that does not exist yet.

 To avoid an error that will terminate the monitor instance, always use done() to check that the iterator has not reached the end of the table before calling this action.]]></Description><Summary><![CDATA[Get the Row this Iterator is pointing at.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns package="com.apama.memorystore" type="Row"/></Action><Action name="done" staticNature=""><Description><![CDATA[Checks whether this Iterator has now reached the end of the Table.

 You should check done() is not true before you call other Iterator actions (except for appendKeys() and getKeys()).]]></Description><Summary><![CDATA[Checks whether this Iterator has now reached the end of the Table.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/></Action></Type><Type category="Event" name="RowChanged"><Description><![CDATA[Sent to the application on every successful row commit in tables the application has subscribed to.

 Supported in distributed stores only, and only for fields named in the schema (extra fields are not supported).

 Events are sent for every change, whether from the local or a remote node, for tables where the subscribe method has been called.

 Some distributed MemoryStore drivers support including new and old values in this event, some just new values, and others - such as TCStore - leave both sequences empty.

 For * example: <pre> <br/>	integer positionRowId := tbl.getFieldIndex("position"); <br/>	RowChanged rowChanged; <br/>	on all RowChanged(storeName = STORE, <br/>	                  tableName = TABLE):rowChanged { <br/>		// we handle things simply by treating an update as a remove followed by an insert: <br/>		if (rowChanged.changeType = RowChanged.REMOVE or <br/>		    rowChanged.changeType = RowChanged.UPDATE) { <br/>			position := position - float.parse(rowChanged.oldFieldValues[positionRowId]); <br/>		} <br/>		if rowChanged.changeType = RowChanged.INSERT or <br/>		   rowChanged.changeType = RowChanged.UPDATE { <br/>			position := position + float.parse(rowChanged.newFieldValues[positionRowId]); <br/>		} <br/>		log "Position is now "+position.toString(); <br/>	} </pre>]]></Description><Summary><![CDATA[Sent to the application on every successful row commit in tables the application has subscribed to.]]></Summary><TypeParameters/><See action="subscribeRowChanged" package="com.apama.memorystore" type="Table"><Description><![CDATA[for subscribing to RowChanged events]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member constant="true" name="INSERT" type="integer" typeValue="1"><Description><![CDATA[Value for changeType when a row is added to a table.]]></Description><Summary><![CDATA[Value for changeType when a row is added to a table.]]></Summary><TypeParameters/></Member><Member constant="true" name="REMOVE" type="integer" typeValue="2"><Description><![CDATA[Value for changeType when a row is removed from a table.]]></Description><Summary><![CDATA[Value for changeType when a row is removed from a table.]]></Summary><TypeParameters/></Member><Member constant="true" name="UPDATE" type="integer" typeValue="3"><Description><![CDATA[Value for changeType when a row is modified in a table.]]></Description><Summary><![CDATA[Value for changeType when a row is modified in a table.]]></Summary><TypeParameters/></Member><Member name="changeType" type="integer"><Description><![CDATA[One of INSERT, REMOVE, UPDATE for rows being added, removed, updated.]]></Description><Summary><![CDATA[One of INSERT, REMOVE, UPDATE for rows being added, removed, updated.]]></Summary><TypeParameters/></Member><Member name="storeName" type="string"><Description><![CDATA[Name of the store that the table is in.]]></Description><Summary><![CDATA[Name of the store that the table is in.]]></Summary><TypeParameters/></Member><Member name="tableName" type="string"><Description><![CDATA[Name of the table that the row is in.]]></Description><Summary><![CDATA[Name of the table that the row is in.]]></Summary><TypeParameters/></Member><Member name="key" type="string"><Description><![CDATA[The key value for the changed row.]]></Description><Summary><![CDATA[The key value for the changed row.]]></Summary><TypeParameters/></Member><Member name="oldFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><Description><![CDATA[Old values of the row, or an empty sequence if not supported by this driver.

 This sequence is always blank when using TCStore or BigMemory.

 The old values of the row, in toString() format, in the order defined by the table's Schema.  For UPDATE changeTypes, this is only populated if the storeFactory bean property rowChangedOldValueRequired is true (the default value is provider-specific).

 For INSERT (or UPDATE if rowChangedOldValueRequired is false), this will be an empty sequence, otherwise it will have as many entries as there are fields in the schema.

 The field values can be recovered by using the parse method on the field's type (e.g. <tt>integer.parse(rc.oldFieldValues[i])</tt>),except for strings which are inserted without any escaping, so do not need to be parsed.

 Use Table.getFieldIndex() to efficiently map a field name to an index in this sequence (although consider caching the index in a variable to avoid unnecessary lookups).]]></Description><Summary><![CDATA[Old values of the row, or an empty sequence if not supported by this driver.]]></Summary><TypeParameters/><See action="getFieldIndex" package="com.apama.memorystore" type="Table"><Description><![CDATA[for mapping from field name to index.]]></Description></See></Member><Member name="newFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><Description><![CDATA[New values of the row, or an empty sequence if not supported by this driver.

 This sequence is always blank when using TCStore.

 The new values of the row, in toString() format, in the order defined by the table's Schema.

 For REMOVE, this will be an empty sequence, otherwise it will have as many entries as there are fields in the schema.

 The field values can be recovered by using the parse method on the field's type (e.g. <tt>integer.parse(rc.newFieldValues[i])</tt>), except for strings which are inserted without any escaping, so do not need to be parsed.

 Use Table.getFieldIndex() to efficiently map a field name to an index in this sequence (although consider caching the index in a variable to avoid unnecessary lookups).]]></Description><Summary><![CDATA[New values of the row, or an empty sequence if not supported by this driver.]]></Summary><TypeParameters/><See action="getFieldIndex" package="com.apama.memorystore" type="Table"><Description><![CDATA[for mapping from field name to index.]]></Description></See></Member><Action name="getChangeTypeString" staticNature=""><Description><![CDATA[Get a display string representing this event's change type.]]></Description><Summary><![CDATA[Get a display string representing this event's change type.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"><Description><![CDATA["INSERT", "REMOVE" or "UPDATE".]]></Description></Returns></Action></Type><Type category="Event" name="Store"><Description><![CDATA[Represents a store, which is a container for a uniquely named collection of tables.]]></Description><Summary><![CDATA[Represents a store, which is a container for a uniquely named collection of tables.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Storage"><Description><![CDATA[Provides actions to prepare and open a Store.]]></Description></See><See package="com.apama.memorystore" type="Table"><Description><![CDATA[Represents the tables in a Store.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Import library="MemoryStorePlugin" name="plugin" private="true"><Description/><Summary/><TypeParameters/></Import><Member name="c" private="true" type="chunk" wildcard="true"><Description/><Summary/><TypeParameters/></Member><Action name="prepare" staticNature=""><Description><![CDATA[Prepare a table so that subsequent open calls for it will succeed.

 If the table already exists, the Schema provided to the prepare function must completely match the existing schema. If it does not already exist, the Schema will be used to create the table.

 The function returns an id; once preparation is complete a Finished event with that id will be sent.

 This call is idempotent - if the table was already successfully prepared, it will return success immediately.]]></Description><Summary><![CDATA[Prepare a table so that subsequent open calls for it will succeed.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete.]]></Description></Returns><Parameters><Parameter name="name" type="string"><Description><![CDATA[A unique name that will be used to identify the new table.]]></Description></Parameter><Parameter name="schema" package="com.apama.memorystore" type="Schema"><Description><![CDATA[The schema identifying the fields of the new table.]]></Description></Parameter></Parameters></Action><Action name="backup" staticNature=""><Description><![CDATA[Create a backup of the Store.

 The backup is created in the specified file, which is overwritten if it already exists.

 Only persistent (on-disk) stores can be backed up.]]></Description><Summary><![CDATA[Create a backup of the Store.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete.]]></Description></Returns><Parameters><Parameter name="filename" type="string"/></Parameters></Action><Action name="getStoreName" staticNature=""><Description><![CDATA[Get the name of this Store.]]></Description><Summary><![CDATA[Get the name of this Store.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/></Action><Action name="hasTable" staticNature=""><Description><![CDATA[Indicate whether or not a Table with the specified name is present in the Store.]]></Description><Summary><![CDATA[Indicate whether or not a Table with the specified name is present in the Store.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"><Description><![CDATA[True if it is safe to call open() on the specified table; false if preparation failed or is still in progress.]]></Description></Returns><Parameters><Parameter name="name" type="string"><Description><![CDATA[The unique table name to check for.]]></Description></Parameter></Parameters></Action><Action name="prepareFromTypeName" staticNature=""><Description><![CDATA[Prepare a table from a type identified from the supplied type name. The type name should identify a users Event.

 <pre>
		integer id := Schema.prepareFromTypeName("MyEventType");
		</pre>]]></Description><Summary><![CDATA[Prepare a table from a type identified from the supplied type name. The type name should identify a users Event.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><See action="prepareFromAny" package="com.apama.memorystore" type="Store"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete.]]></Description></Returns><Parameters><Parameter name="typeName" type="string"><Description><![CDATA[The type name to use as the table name and schema.]]></Description></Parameter></Parameters></Action><Action name="persist" staticNature=""><Description><![CDATA[Persist committed changes back to stable storage, asynchronously.

 Only on-disk persistent stores can be persisted using this action. It is not possible to call this method on Correlator-persistent tables since all changes committed to such tables will be written to disk automatically in the same transaction as changes to the state of persistent EPL monitors.]]></Description><Summary><![CDATA[Persist committed changes back to stable storage, asynchronously.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete.]]></Description></Returns></Action><Action name="open" staticNature=""><Description><![CDATA[Open the specified table, once it has been prepared.

 It is an error to call this before a prepare call for the table has finished without error.]]></Description><Summary><![CDATA[Open the specified table, once it has been prepared.]]></Summary><TypeParameters/><See action="prepare" package="com.apama.memorystore" type="Store"><Description><![CDATA[This action must not be called until prepare has completed successfully.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns package="com.apama.memorystore" type="Table"/><Parameters><Parameter name="name" type="string"><Description><![CDATA[The name of the table to be opened, which must be the same as the name used when the table was first prepared.]]></Description></Parameter></Parameters></Action><Action name="prepareFromAny" staticNature=""><Description><![CDATA[Prepare a table from a supplied type (a users Event) using the type name as the table name and the fields and field types as the schema.

 <pre>
		integer id := Schema.prepareFromAny(new MyEventType);
		</pre>]]></Description><Summary><![CDATA[Prepare a table from a supplied type (a users Event) using the type name as the table name and the fields and field types as the schema.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Finished"><Description><![CDATA[A Finished event will be sent when this asynchronous operation has completed.]]></Description></See><See action="prepare" package="com.apama.memorystore" type="Store"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Returns type="integer"><Description><![CDATA[The unique identifier for this operation, which will be included in the Finished event sent after the operation is complete.]]></Description></Returns><Parameters><Parameter name="prototype" type="any"><Description><![CDATA[Any type value to use as the table name and schema]]></Description></Parameter></Parameters></Action></Type><Type category="Event" name="ForwardMemoryStoreUpdatesTo"><Description><![CDATA[Requests Scenario Service updates for an exposed MemoryStore to be forwarded to the specified Correlator context.

 Note that this is inefficient and does not implement proper flow control. Only use for testing or debugging.]]></Description><Summary><![CDATA[Requests Scenario Service updates for an exposed MemoryStore to be forwarded to the specified Correlator context.]]></Summary><TypeParameters/><See field="exposeMemoryView" package="com.apama.memorystore" type="Schema"><Description><![CDATA[Only tables that are configured to expose their contents will be affected by this event.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="ctx" type="context"><Description><![CDATA[The context to which events should be forwarded.]]></Description><Summary><![CDATA[The context to which events should be forwarded.]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="Row"><Description><![CDATA[Represents an ordered and typed set of named fields in a table, with a key that uniquely identifies the row within the table.

 A Row is an atomic snapshot of the data in the table and once returned, a Row's contents are guaranteed to be consistent and unchanging.

 Any changes the user makes to a Row are local until commit is called.]]></Description><Summary><![CDATA[Represents an ordered and typed set of named fields in a table, with a key that uniquely identifies the row within the table.]]></Summary><TypeParameters/><See package="com.apama.memorystore" type="Table"><Description><![CDATA[A table holds a collection of rows.]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Import library="MemoryStorePlugin" name="plugin" private="true"><Description/><Summary/><TypeParameters/></Import><Member name="c" private="true" type="chunk" wildcard="true"><Description/><Summary/><TypeParameters/></Member><Action name="getParsed" staticNature=""><Description><![CDATA[Get the value of the specified field in this row parsed to the specified typeName.]]></Description><Summary><![CDATA[Get the value of the specified field in this row parsed to the specified typeName.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Returns type="any"/><Parameters><Parameter name="name" type="string"/><Parameter name="typeName" type="string"/></Parameters></Action><Action name="commit" staticNature=""><Description><![CDATA[Try to commit changes from this Row back to the table, which could result in an exception being thrown if the Row is not up to date.

 If nothing else has modified the row in the table since this Row was created, the changes are committed so other users can see them.

 Otherwise, an exception is thrown and the table is left unchanged.

 If there is any chance that the same row may be written to concurrently - for example by multiple correlator contexts, and/or if using a distributed MemoryStore - use Row.tryCommit() instead of Row.commit() so that it is possible to recover from this situation when it occurs or use Row.forceCommit() to commit the changes forcefully.

 Note that a MemoryStore commit operation synchronously writes changes made to the local Row instance back to the table which is shared by all monitors inside the Correlator (or the distributed store), but does not cause a persistent write to disk (see Table#persist).]]></Description><Summary><![CDATA[Try to commit changes from this Row back to the table, which could result in an exception being thrown if the Row is not up to date.]]></Summary><TypeParameters/><See action="tryCommit" package="com.apama.memorystore" type="Row"><Description/></See><See action="tryCommitOrUpdate" package="com.apama.memorystore" type="Row"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="setInteger" staticNature=""><Description><![CDATA[Set the value of the specified field in this row (must only be used on integer fields).]]></Description><Summary><![CDATA[Set the value of the specified field in this row (must only be used on integer fields).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="name" type="string"/><Parameter name="i" type="integer"/></Parameters></Action><Action name="update" staticNature=""><Description><![CDATA[Update the local Row event to reflect the current state of the shared MemoryStore table, losing any local modifications.

 row.update() has a very similar effect to r := t.get(r.getKey()), but is more efficient and doesn't require access to the table.]]></Description><Summary><![CDATA[Update the local Row event to reflect the current state of the shared MemoryStore table, losing any local modifications.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="getInteger" staticNature=""><Description><![CDATA[Get the value of the specified field in this row (must only be used on integer fields).]]></Description><Summary><![CDATA[Get the value of the specified field in this row (must only be used on integer fields).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="integer"/><Parameters><Parameter name="name" type="string"/></Parameters></Action><Action name="getFloat" staticNature=""><Description><![CDATA[Get the value of the specified field in this row (must only be used on float fields).]]></Description><Summary><![CDATA[Get the value of the specified field in this row (must only be used on float fields).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="float"/><Parameters><Parameter name="name" type="string"/></Parameters></Action><Action name="remove" staticNature=""><Description><![CDATA[Mark the row for deletion when the table is committed.

 Fields cannot be accessed after this call, until the removal is successfully committed (or reverted using update).]]></Description><Summary><![CDATA[Mark the row for deletion when the table is committed.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="getStoreName" staticNature=""><Description><![CDATA[Get the name of the Store that contains this Row's Table.]]></Description><Summary><![CDATA[Get the name of the Store that contains this Row's Table.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/></Action><Action name="get" staticNature=""><Description><![CDATA[Get the value of the specified field in this row (can be used on all types). This will return a string for types that cannot be stored. Use getParsed() to parse to a type.

 An exception will be thrown if the specified field name is not present in this row.

 If it is not known whether the field name exists or not, use getKeys().indexOf(...) to find out, or use toDictionary.getOr(...).]]></Description><Summary><![CDATA[Get the value of the specified field in this row (can be used on all types). This will return a string for types that cannot be stored. Use getParsed() to parse to a type.]]></Summary><TypeParameters/><See action="getParsed" package="com.apama.memorystore" type="Row"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Returns type="any"/><Parameters><Parameter name="name" type="string"/></Parameters></Action><Action name="inTable" staticNature=""><Description><![CDATA[Indicate whether this row was in the table when the Row was created or updated.

 It is possible to construct a Row that has no corresponding entry in the table, in which case all fields have default values.

 Calling commit on a Row for which inTable()=false will create the row.]]></Description><Summary><![CDATA[Indicate whether this row was in the table when the Row was created or updated.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/></Action><Action name="getBoolean" staticNature=""><Description><![CDATA[Get the value of the specified field in this row (must only be used on boolean fields).]]></Description><Summary><![CDATA[Get the value of the specified field in this row (must only be used on boolean fields).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/><Parameters><Parameter name="name" type="string"/></Parameters></Action><Action name="copy" staticNature=""><Description><![CDATA[Copy the contents of the specified other Row into this one.

 The two rows that these Row events represent must have the same schema but they need not be in the same table.

 r1.copy(r2) is a more efficient equivalent to r1.setX("a", r2.getX("a")) for every field.

 You cannot copy a row between a correlator-persistent store and an in-memory, on-disk or distributed store.]]></Description><Summary><![CDATA[Copy the contents of the specified other Row into this one.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="other" package="com.apama.memorystore" type="Row"/></Parameters></Action><Action name="setAll" staticNature=""><Description><![CDATA[Set all values in this row from all available fields in the supplied any type.]]></Description><Summary><![CDATA[Set all values in this row from all available fields in the supplied any type.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Parameters><Parameter name="value" type="any"><Description><![CDATA[Any type value (event or dictionary) to take the field values from]]></Description></Parameter></Parameters></Action><Action name="getKey" staticNature=""><Description><![CDATA[Get the key for this Row.

 It cannot be changed.]]></Description><Summary><![CDATA[Get the key for this Row.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/></Action><Action name="getDecimal" staticNature=""><Description><![CDATA[Get the value of the specified field in this row (must only be used on decimal fields).]]></Description><Summary><![CDATA[Get the value of the specified field in this row (must only be used on decimal fields).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="decimal"/><Parameters><Parameter name="name" type="string"/></Parameters></Action><Action name="setFloat" staticNature=""><Description><![CDATA[Set the value of the specified field in this row (must only be used on float fields).]]></Description><Summary><![CDATA[Set the value of the specified field in this row (must only be used on float fields).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="name" type="string"/><Parameter name="f" type="float"/></Parameters></Action><Action name="set" staticNature=""><Description><![CDATA[Set the value of the specified field in this row (can be used with all types). Will use the string form if needed.

 If name is a non-schema field and the store is a distributed store which supports them, a new field will be added. If any is empty and the above is true, then the field will be removed from the row. Otherwise this method will throw.]]></Description><Summary><![CDATA[Set the value of the specified field in this row (can be used with all types). Will use the string form if needed.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Parameters><Parameter name="name" type="string"/><Parameter name="value" type="any"/></Parameters></Action><Action name="getAll" staticNature=""><Description><![CDATA[Fill in value of all keys in the supplied 'any' with values from the row.]]></Description><Summary><![CDATA[Fill in value of all keys in the supplied 'any' with values from the row.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Returns type="any"><Description><![CDATA[The same instance passed in as prototype, filled in with values from this row.]]></Description></Returns><Parameters><Parameter name="prototype" type="any"><Description><![CDATA[Any type value (an event or non-empty dictionary) which will be modified in-place with the current values from this row.]]></Description></Parameter></Parameters></Action><Action name="setDecimal" staticNature=""><Description><![CDATA[Set the value of the specified field in this row (must only be used on decimal fields).]]></Description><Summary><![CDATA[Set the value of the specified field in this row (must only be used on decimal fields).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="name" type="string"/><Parameter name="d" type="decimal"/></Parameters></Action><Action name="toAny" staticNature=""><Description><![CDATA[Get the row as an any using the type the Store was created with (using prepareFromAny() or prepareFromTypeName()).

 This is equivalent to calling getAll(any.newInstance(getTableName())). This action can be used only if the table name is a valid Apama type. Use getAll() instead if the store was not created from an Apama type.]]></Description><Summary><![CDATA[Get the row as an any using the type the Store was created with (using prepareFromAny() or prepareFromTypeName()).]]></Summary><TypeParameters/><See action="prepareFromAny" package="com.apama.memorystore" type="Store"><Description/></See><See action="prepareFromTypeName" package="com.apama.memorystore" type="Store"><Description/></See><See action="getAll" package="com.apama.memorystore" type="Row"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="any"/></Action><Action name="getTableName" staticNature=""><Description><![CDATA[Get the name of the Table that contains this Row.]]></Description><Summary><![CDATA[Get the name of the Table that contains this Row.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/></Action><Action name="getString" staticNature=""><Description><![CDATA[Get the value of the specified field in this row (must only be used on string fields).]]></Description><Summary><![CDATA[Get the value of the specified field in this row (must only be used on string fields).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/><Parameters><Parameter name="name" type="string"/></Parameters></Action><Action name="getKeys" staticNature=""><Description><![CDATA[Get all of the field names held in this Row. These are all of the valid values that can be passed to get(). Will include all Schema field names followed by any extra fields if the driver supports them.]]></Description><Summary><![CDATA[Get all of the field names held in this Row. These are all of the valid values that can be passed to get(). Will include all Schema field names followed by any extra fields if the driver supports them.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Returns type="sequence"><Parameters><Parameter type="string"/></Parameters></Returns></Action><Action name="tryCommit" staticNature=""><Description><![CDATA[Try to commit changes from this Row back to the table, returning false if the Row is not up to date.

 If nothing else has modified the row in the table since this Row was created, the changes are committed so other users can see them and true is returned.

 Otherwise, false is returned and the table is left unchanged. Do not repeatedly call tryCommit() without also calling update(), or use the more efficient Row.tryCommitOrUpdate().

 Note that a MemoryStore commit operation synchronously writes changes made to the local Row instance back to the table which is shared by all monitors inside the Correlator (or the distributed store), but does not cause a persistent write to disk (see Table#persist).]]></Description><Summary><![CDATA[Try to commit changes from this Row back to the table, returning false if the Row is not up to date.]]></Summary><TypeParameters/><See action="tryCommitOrUpdate" package="com.apama.memorystore" type="Row"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"><Description><![CDATA[true if the table was modified; false if an error occurred and the table was not changed.]]></Description></Returns></Action><Action name="toDictionary" staticNature=""><Description><![CDATA[Get a dictionary copy of the Row.]]></Description><Summary><![CDATA[Get a dictionary copy of the Row.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.1]]></Description></Since><Returns type="dictionary"><Parameters><Parameter type="string"/><Parameter type="any"/></Parameters></Returns></Action><Action name="removeNonSchema" staticNature=""><Description><![CDATA[Remove a non-schema field from the row.

 Only functions on non-schema fields with a supported distributed store.]]></Description><Summary><![CDATA[Remove a non-schema field from the row.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Since><Description><![CDATA[10.3]]></Description></Since><Parameters><Parameter name="name" type="string"/></Parameters></Action><Action name="setString" staticNature=""><Description><![CDATA[Set the value of the specified field in this row (must only be used on string fields).]]></Description><Summary><![CDATA[Set the value of the specified field in this row (must only be used on string fields).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="name" type="string"/><Parameter name="s" type="string"/></Parameters></Action><Action name="tryCommitOrUpdate" staticNature=""><Description><![CDATA[Try to commit, or update (losing local modifications) if not.

 This is a more efficient equivalent to calling tryCommit then calling update if the commit fails. Typical usage would be to have a loop that makes some modifications to a row, calls tryCommitOrUpdate, and continues to loop (re-instating the local modifications and calling tryCommitOrUpdate again) until it returns true.

 Note that a MemoryStore commit operation synchronously writes changes made to the local Row instance back to the table which is shared by all monitors inside the Correlator (or the distributed store), but does not cause a persistent write to disk (see Table#persist).]]></Description><Summary><![CDATA[Try to commit, or update (losing local modifications) if not.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"><Description><![CDATA[true if the commit succeeded, false if the commit failed but the row has been updated ready for a retry attempt.]]></Description></Returns></Action><Action name="forceCommit" staticNature=""><Description><![CDATA[Commit this Row back to the table even if the Row is not up to date.

 If this Row is marked for deletion using Row.remove() then forceCommit will unconditionally remove the Row from the table.

 Note that a MemoryStore commit operation synchronously writes changes made to the local Row instance back to the table which is shared by all monitors inside the Correlator (or the distributed store), but does not cause a persistent write to disk (see Table#persist).]]></Description><Summary><![CDATA[Commit this Row back to the table even if the Row is not up to date.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="setBoolean" staticNature=""><Description><![CDATA[Set the value of the specified field in this row (must only be used on boolean fields).]]></Description><Summary><![CDATA[Set the value of the specified field in this row (must only be used on boolean fields).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="name" type="string"/><Parameter name="b" type="boolean"/></Parameters></Action></Type><Type category="Event" name="MissedRowChanges"><Description><![CDATA[Optionally sent to the application if the driver has detected that some of the RowChanged events may have been dropped for a table the application has subscribed to.

 Supported in distributed stores only.]]></Description><Summary><![CDATA[Optionally sent to the application if the driver has detected that some of the RowChanged events may have been dropped for a table the application has subscribed to.]]></Summary><TypeParameters/><See action="subscribeRowChanged" package="com.apama.memorystore" type="Table"><Description><![CDATA[for subscribing to RowChanged and MissedRowChanges events]]></Description></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="storeName" type="string"><Description><![CDATA[Name of the store that the table is in.]]></Description><Summary><![CDATA[Name of the store that the table is in.]]></Summary><TypeParameters/></Member><Member name="tableName" type="string"><Description><![CDATA[Name of the table that has received a disconnection.]]></Description><Summary><![CDATA[Name of the table that has received a disconnection.]]></Summary><TypeParameters/></Member></Type><Type category="Monitor" name="MemoryStoreScenarioImpl" private="true"><Description><![CDATA[Makes data in MemoryStore available for viewing by any dashboard client that uses the Scenario Service, or as a DataView.]]></Description><Summary><![CDATA[Makes data in MemoryStore available for viewing by any dashboard client that uses the Scenario Service, or as a DataView.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="GetAllConfiguration"/><Reference package="com.apama.scenario" type="Scenario"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="ConfigureUpdates"/><Reference package="com.apama.scenario" type="Scenario"/></Sends><Listens><Reference package="com.apama.scenario" type="AllConfiguration"/><Reference package="com.apama.scenario" type="ConfigureUpdates"/><Reference package="com.apama.scenario" type="Create"/><Reference package="com.apama.scenario" type="Delete"/><Reference package="com.apama.scenario" type="Edit"/><Reference package="com.apama.memorystore" type="ForwardMemoryStoreUpdatesTo"/><Reference package="com.apama.scenario" type="Instance"/><Reference package="com.apama.scenario" type="RequestInstancesDone"/><Reference package="com.apama.scenario" type="RequestInstancesInternal"/><Reference package="com.apama.scenario" type="Scenario"/><Reference package="com.apama.scenario" type="StartScenarioRecovery"/><Reference package="com.apama.scenario" type="Update"/></Listens></Type></Package><Package depth="../../../" display="com.apama.scenarios" name="com.apama.scenarios"><Type category="Event" name="DeleteAllScenarios"><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member constant="true" name="CHANNEL" type="string" typeValue="&quot;ScenarioDeleter&quot;"><TypeParameters/></Member></Type><Type category="Event" name="DeleteScenariosByUser"><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="owner" type="string"><TypeParameters/></Member></Type><Type category="Monitor" name="ScenarioDeleterSupport"><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="com.apama.scenarios" type="DeleteAllScenarios"/><Reference package="com.apama.scenarios" type="DeleteScenariosByUser"/></Sends><Listens><Reference package="com.apama.scenarios" type="DeleteAllScenarios"/><Reference package="com.apama.scenarios" type="DeleteScenariosByUser"/></Listens></Type></Package><Package depth="../../../" display="com.apama.scenario" name="com.apama.scenario"><Type category="Event" name="Delete"><Description><![CDATA[Request that a specific instance of a specific scenario is deleted.

 See also: Deleted(), Acknowledge()

 Direction: From the client to the correlator.

 Response: Acknowledge()]]></Description><Summary><![CDATA[Request that a specific instance of a specific scenario is deleted.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member></Type><Type category="Event" name="ScenarioServiceLoaded"><Description><![CDATA[Indicates this shared MonitorScript has been loaded.

 Direction: From the correlator to the client.

 Channel: com.apama.scenario to broadcast when loaded.]]></Description><Summary><![CDATA[Indicates this shared MonitorScript has been loaded.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Type><Type category="Event" name="ScenarioServiceUpdaterMultipleInstances"><Description><![CDATA[Utility event for tracking configuration for a given scenario. This event is suitable for use by monitors which spawn per scenario, but not per instance. (e.g. ScenarioService, DataViewService)

 actions starting with an underscore should be considered private and not called by users of this event.

 Note that this updater only honours sendThrottledUser changes at the next throttling period (it does not record the owner if sendThrottledUser is not true)]]></Description><Summary><![CDATA[Utility event for tracking configuration for a given scenario. This event is suitable for use by monitors which spawn per scenario, but not per instance. (e.g. ScenarioService, DataViewService)]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Acknowledge"/><Reference package="com.apama.scenario" type="Created"/><Reference package="com.apama.scenario" type="Deleted"/><Reference package="com.apama.scenario" type="Edited"/><Reference package="com.apama.scenario" type="Instance"/><Reference package="com.apama.scenario" type="InstanceDied"/><Reference package="com.apama.scenario" type="StateChange"/><Reference package="com.apama.scenario" type="Update"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Acknowledge"/><Reference package="com.apama.scenario" type="Instance"/><Reference package="com.apama.scenario" type="InstanceDied"/><Reference package="com.apama.scenario" type="OperationCompleted"/><Reference package="com.apama.scenario" type="RequestInstancesParallelDone"/><Reference package="com.apama.scenario" type="StateChange"/><Reference package="com.apama.scenario" type="Update"/></Sends><Listens><Reference package="com.apama.scenario" type="Created"/><Reference package="com.apama.scenario" type="Deleted"/><Reference package="com.apama.scenario" type="Edited"/><Reference package="com.apama.scenario" type="InstanceDied"/><Reference package="com.apama.scenario" type="SendQueuedUpdatesNow"/><Reference package="com.apama.scenario" type="Update"/></Listens><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="throttlingListener" type="listener"><TypeParameters/></Member><Member name="base" package="com.apama.scenario" type="ScenarioServiceUpdaterBase"><TypeParameters/></Member><Member name="currentlySendingThrottledUser" type="boolean"><TypeParameters/></Member><Member name="updates" type="dictionary"><Parameters><Parameter type="integer"/><Parameter package="com.apama.scenario" type="Update"/></Parameters><TypeParameters/></Member><Member name="owners" type="dictionary"><Parameters><Parameter type="integer"/><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="mainContext" type="context"><TypeParameters/></Member><Member name="controlChannel" type="string"><TypeParameters/></Member><Member name="rawChannel" type="string"><TypeParameters/></Member><Member name="dataChannel" type="string"><TypeParameters/></Member><Action name="emitEdited" staticNature=""><Description><![CDATA[Called to send a new Edited event.]]></Description><Summary><![CDATA[Called to send a new Edited event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Edited"/></Routes><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/><Parameter name="scenarioInstanceId" type="integer"/><Parameter name="inputVariables" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter><Parameter name="outputVariables" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter><Parameter name="owner" type="string"/></Parameters></Action><Action name="init" staticNature=""><Description><![CDATA[Called by monitor for each scenario Will maintain configuration for this scenario Id]]></Description><Summary><![CDATA[Called by monitor for each scenario Will maintain configuration for this scenario Id]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="sId" type="string"/><Parameter name="mainCtx" type="context"/></Parameters></Action><Action name="_configurationUpdated" staticNature=""><Description><![CDATA[called in instances (not factories) when configuration has changed]]></Description><Summary><![CDATA[called in instances (not factories) when configuration has changed]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="emitInstance" staticNature=""><Description><![CDATA[Called to send an instance in response to a RequestInstancesInternal event]]></Description><Summary><![CDATA[Called to send an instance in response to a RequestInstancesInternal event]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Instance"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Instance"/><Reference package="com.apama.scenario" type="RequestInstancesParallelDone"/></Sends><Listens/><Spawns/><Parameters><Parameter name="request" package="com.apama.scenario" type="RequestInstancesInternal"/><Parameter name="scenarioInstanceId" type="integer"/><Parameter name="owner" type="string"/><Parameter name="state" type="string"/><Parameter name="input" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter><Parameter name="output" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="emitAcknowledgement" staticNature=""><Description><![CDATA[Called to send a new Acknowledgement event.]]></Description><Summary><![CDATA[Called to send a new Acknowledgement event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Acknowledge"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Acknowledge"/></Sends><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/><Parameter name="scenarioInstanceId" type="integer"/><Parameter name="output" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="_init" staticNature=""><Description><![CDATA[Implementation of init and init_cb]]></Description><Summary><![CDATA[Implementation of init and init_cb]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens><Reference package="com.apama.scenario" type="SendQueuedUpdatesNow"/></Listens><Spawns/><Parameters><Parameter name="sId" type="string"/><Parameter name="mainCtx" type="context"/><Parameter name="cb_initComplete" type="action"><Parameters/></Parameter></Parameters></Action><Action name="notifyInstanceDied" staticNature=""><Description><![CDATA[Called to notify the scenario service monitor that we have gone away - must be called after emitting any events regarding this instance going away. Implied by emitDeleted.]]></Description><Summary><![CDATA[Called to notify the scenario service monitor that we have gone away - must be called after emitting any events regarding this instance going away. Implied by emitDeleted.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="InstanceDied"/></Sends><Listens/><Spawns/><Parameters><Parameter name="scenarioInstanceId" type="integer"/></Parameters></Action><Action name="isRouteUpdate" staticNature=""><Description><![CDATA[Get whether this scenario should route updates]]></Description><Summary><![CDATA[Get whether this scenario should route updates]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/></Action><Action name="emitReceivedEvents" staticNature=""><Description><![CDATA[Called to send any received events (except for instance) for this scenario.]]></Description><Summary><![CDATA[Called to send any received events (except for instance) for this scenario.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Update"/></Sends><Listens><Reference package="com.apama.scenario" type="InstanceDied"/><Reference package="com.apama.scenario" type="Edited"/><Reference package="com.apama.scenario" type="Deleted"/><Reference package="com.apama.scenario" type="Update"/><Reference package="com.apama.scenario" type="Created"/></Listens><Spawns/></Action><Action name="flushPending" staticNature=""><Description><![CDATA[flush any pending update on the throttled channel.]]></Description><Summary><![CDATA[flush any pending update on the throttled channel.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="emitUpdate_time" staticNature=""><Description><![CDATA[Called when a new update is available. (This variant allows setting of the time parameter)]]></Description><Summary><![CDATA[Called when a new update is available. (This variant allows setting of the time parameter)]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Update"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Update"/></Sends><Listens/><Spawns/><Parameters><Parameter name="scenarioInstanceId" type="integer"/><Parameter name="time" type="float"/><Parameter name="output" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter><Parameter name="owner" type="string"/></Parameters></Action><Action name="emitReceivedInstance" staticNature=""><Description><![CDATA[Called to send an instance that has already been seen in the current context]]></Description><Summary><![CDATA[Called to send an instance that has already been seen in the current context]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Instance"/></Sends><Listens/><Spawns/><Parameters><Parameter name="request" package="com.apama.scenario" type="RequestInstancesInternal"/><Parameter name="instance" package="com.apama.scenario" type="Instance"/></Parameters></Action><Action name="destroy" staticNature=""><Description><![CDATA[Kill any listeners this object has started]]></Description><Summary><![CDATA[Kill any listeners this object has started]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="_sendThrottledUpdates" staticNature=""><Description><![CDATA[actually send an update on the throttled channel]]></Description><Summary><![CDATA[actually send an update on the throttled channel]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Update"/></Sends><Listens/><Spawns/></Action><Action name="emitUpdate" staticNature=""><Description><![CDATA[Called when a new update is available.]]></Description><Summary><![CDATA[Called when a new update is available.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="scenarioInstanceId" type="integer"/><Parameter name="output" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter><Parameter name="owner" type="string"/></Parameters></Action><Action name="init_cb" staticNature=""><Description><![CDATA[Called by monitor for each scenario Will maintain configuration for this scenario Id]]></Description><Summary><![CDATA[Called by monitor for each scenario Will maintain configuration for this scenario Id]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="sId" type="string"/><Parameter name="mainCtx" type="context"/><Parameter name="cb_initComplete" type="action"><Parameters/></Parameter></Parameters></Action><Action name="emitOpCompleted" staticNature=""><Description><![CDATA[Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.]]></Description><Summary><![CDATA[Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="OperationCompleted"/></Sends><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/><Parameter name="scenarioInstanceId" type="integer"/></Parameters></Action><Action name="_setupThrottleListener" staticNature=""><Description><![CDATA[set up a throttled listener according to throttlePeriod control]]></Description><Summary><![CDATA[set up a throttled listener according to throttlePeriod control]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="emitCreated" staticNature=""><Description><![CDATA[Called to send a new Created event.]]></Description><Summary><![CDATA[Called to send a new Created event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Created"/></Routes><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/><Parameter name="scenarioInstanceId" type="integer"/><Parameter name="owner" type="string"/><Parameter name="state" type="string"/><Parameter name="inputVariables" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter><Parameter name="outputVariables" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="emitInstanceDied" staticNature=""><Description><![CDATA[Called to send an instance Died event (either of failed, ended)]]></Description><Summary><![CDATA[Called to send an instance Died event (either of failed, ended)]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="InstanceDied"/></Routes><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="scenarioInstanceId" type="integer"/><Parameter name="owner" type="string"/></Parameters></Action><Action name="flushPendingInstance" staticNature=""><Description><![CDATA[Flush pending throttled data for one instance]]></Description><Summary><![CDATA[Flush pending throttled data for one instance]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Update"/></Sends><Listens/><Spawns/><Parameters><Parameter name="scenarioInstanceId" type="integer"/></Parameters></Action><Action name="emitDeleted" staticNature=""><Description><![CDATA[Called to send a new Deleted event.]]></Description><Summary><![CDATA[Called to send a new Deleted event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Deleted"/></Routes><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/><Parameter name="scenarioInstanceId" type="integer"/><Parameter name="owner" type="string"/></Parameters></Action><Action name="emitNack" staticNature=""><Description><![CDATA[Called to send a new Nak event.]]></Description><Summary><![CDATA[Called to send a new Nak event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Acknowledge"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Acknowledge"/></Sends><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/><Parameter name="scenarioInstanceId" type="integer"/></Parameters></Action><Action name="emitStateChange" staticNature=""><Description><![CDATA[Called to send a new StateChange event.]]></Description><Summary><![CDATA[Called to send a new StateChange event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="StateChange"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="StateChange"/></Sends><Listens/><Spawns/><Parameters><Parameter name="state" type="string"/><Parameter name="scenarioInstanceId" type="integer"/><Parameter name="owner" type="string"/></Parameters></Action></Type><Type category="Event" name="Configuration"><Description><![CDATA[The current configuration for a given scenario and the default configuration]]></Description><Summary><![CDATA[The current configuration for a given scenario and the default configuration]]></Summary><TypeParameters/><See package="com.apama.scenario" type="ConfigureUpdates"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="defaults" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="configuration" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters><TypeParameters/></Member></Type><Type category="Event" name="Instance"><Description><![CDATA[Provides a dump of the current state of a scenario instance. The event definition is identical to the Created event, and includes the owner (user), initial state, and current values for all input fields and all output fields.

 Instance events are sent in response to RequestInstancesOnChannel event and the deprecated RequestInstancesInternal event;

 See also: RequestInstancesOnChannel, RequestInstancesDone, RequestInstancesInternal

 Direction: From the correlator to the client.

 Channel: A unique private channel as specified by the client in a RequestScenariosOnChannel event.

 Note that previously it would have been on <scenarioId>.Data and <scenarioId>.Data.Raw, but that behaviour is now deprecated.]]></Description><Summary><![CDATA[Provides a dump of the current state of a scenario instance. The event definition is identical to the Created event, and includes the owner (user), initial state, and current values for all input fields and all output fields.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="owner" type="string"><TypeParameters/></Member><Member name="state" type="string"><TypeParameters/></Member><Member name="inputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="outputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member></Type><Type category="Event" name="RequestInstancesInternal"><Description><![CDATA[Request that each instance of the specified scenario send an Instance event out on the scenario Data or Raw channel. When all instances for the scenario have been sent out, a final RequestInstancesDone event will be sent on the same channel.

 See also: Instance, RequestInstancesDone, RequestInstancesOnChannel, RequestInstancesOnChannelByUser

 Direction: From the ScenarioService to the scenario

 Response: Instance() from each scenario instance, RequestInstancesDone when finished.]]></Description><Summary><![CDATA[Request that each instance of the specified scenario send an Instance event out on the scenario Data or Raw channel. When all instances for the scenario have been sent out, a final RequestInstancesDone event will be sent on the same channel.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="channel" type="string"><TypeParameters/></Member><Member name="internal" type="boolean"><TypeParameters/></Member><Member name="owner" type="string"><TypeParameters/></Member><Member name="ownerFilter" type="boolean"><TypeParameters/></Member></Type><Type category="Event" name="ScenarioUnloaded"><Description><![CDATA[Indicates that a specific Scenario definition is being unloaded.

 Direction: From the correlator to the client.

 Channel: <scenarioId>.Control]]></Description><Summary><![CDATA[Indicates that a specific Scenario definition is being unloaded.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member></Type><Type category="Event" name="AllConfiguration"><Description><![CDATA[Response all configuration]]></Description><Summary><![CDATA[Response all configuration]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="requestId" type="integer"><TypeParameters/></Member><Member name="defaultConfig" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="configurations" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter></Parameters><TypeParameters/></Member></Type><Type category="Event" name="Edit"><Description><![CDATA[Request that a specific instance of a specific scenario is edited (the input field values are changed).

 See also: Edited(), Acknowledge()

 Direction: From the client to the correlator.

 Response: Acknowledge()]]></Description><Summary><![CDATA[Request that a specific instance of a specific scenario is edited (the input field values are changed).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="inputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member></Type><Type category="Event" name="RequestInstancesParallel"><Description><![CDATA[Trigger discovery of a parallel scenario. Sent from a sub-monitor of ScenarioService to RequestInstancesHandler to create a new sub-monitor.]]></Description><Summary><![CDATA[Trigger discovery of a parallel scenario. Sent from a sub-monitor of ScenarioService to RequestInstancesHandler to create a new sub-monitor.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="request" package="com.apama.scenario" type="RequestInstancesInternal"><TypeParameters/></Member><Member name="instances" type="dictionary"><Parameters><Parameter type="integer"/><Parameter type="context"/></Parameters><TypeParameters/></Member><Member name="highestInstanceId" type="integer"><TypeParameters/></Member></Type><Type category="Event" name="Update"><Description><![CDATA[Contains updated scenario instance output fields. Note that this is the ONLY event type that is sent on the "<scenarioId>.Data" channel.

 Direction: From the correlator to the client.

 Channel: <scenarioId>.Data and <scenarioId>.Data.Raw]]></Description><Summary><![CDATA[Contains updated scenario instance output fields. Note that this is the ONLY event type that is sent on the "<scenarioId>.Data" channel.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="timeStamp" type="float"><TypeParameters/></Member><Member name="outputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member></Type><Type category="Event" name="RequestInstancesParallelDone"><Description><![CDATA[Discovery protocol of a parallel scenario. Sent from a scenario instance to RequestInstancesHandler.]]></Description><Summary><![CDATA[Discovery protocol of a parallel scenario. Sent from a scenario instance to RequestInstancesHandler.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member></Type><Type category="Event" name="Created"><Description><![CDATA[Notifies all interested clients that a new instance of a specific scenario has been created. The event provides the owner (user), initial state, and initial values for all input fields and all output fields.

 See also: Create()

 Direction: From the correlator to the client.

 Channel: <scenarioId>.Data and <scenarioId>.Data.Raw]]></Description><Summary><![CDATA[Notifies all interested clients that a new instance of a specific scenario has been created. The event provides the owner (user), initial state, and initial values for all input fields and all output fields.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="owner" type="string"><TypeParameters/></Member><Member name="state" type="string"><TypeParameters/></Member><Member name="inputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="outputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member></Type><Type category="Event" name="ParentChildRelationship"><Description><![CDATA[Notifies the interested clients of child scenarios created from a parent scenario.

 Direction: Internal in the correlator

 Channel: <none>]]></Description><Summary><![CDATA[Notifies the interested clients of child scenarios created from a parent scenario.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="parentScenarioId" type="string"><TypeParameters/></Member><Member name="parentScenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="childScenarioId" type="string"><TypeParameters/></Member><Member name="childScenarioInstanceId" type="integer"><TypeParameters/></Member></Type><Type category="Event" name="Create"><Description><![CDATA[Request that a new instance of a specific scenario is created.

 See also: Created(), Acknowledge()

 Direction: From the client to the correlator.

 Response: Acknowledge()]]></Description><Summary><![CDATA[Request that a new instance of a specific scenario is created.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="owner" type="string"><TypeParameters/></Member><Member name="inputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member></Type><Type category="Event" name="ScenarioFinished"><Description><![CDATA[A scenario has finished running, but is still discoverable. (i.e. entered end state or failed - but not deleted). Note that this event contains the state as of the last Update/ Edited event - i.e. if an action modified an output variable and then caused the scenario to fail, the prior modification would not be reflected in this event.

 This event contains sufficient information for discovery of the scenario instance later

 Direction: from scenarios to the ScenarioService sub-monitor (spawned per scenario)]]></Description><Summary><![CDATA[A scenario has finished running, but is still discoverable. (i.e. entered end state or failed - but not deleted). Note that this event contains the state as of the last Update/ Edited event - i.e. if an action modified an output variable and then caused the scenario to fail, the prior modification would not be reflected in this event.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="owner" type="string"><TypeParameters/></Member><Member name="state" type="string"><TypeParameters/></Member><Member name="inputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="outputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member></Type><Type category="Event" name="ScenarioServiceUnloaded"><Description><![CDATA[Indicates this shared MonitorScript is being unloaded.

 Direction: From the correlator to the client.

 Channel: com.apama.scenario to broadcast when unloaded.]]></Description><Summary><![CDATA[Indicates this shared MonitorScript is being unloaded.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Type><Type category="Event" name="SetThrottlingPeriod"><Description><![CDATA[Set the period over which updates will be queued and coalesced before being sent out on the data channel. Defaults to zero, which means they won't be queued. If it is negative then we won't send any updates on the data channel. This event is deprecated and the ConfigureUpdates event should be used instead (see below)]]></Description><Summary><![CDATA[Set the period over which updates will be queued and coalesced before being sent out on the data channel. Defaults to zero, which means they won't be queued. If it is negative then we won't send any updates on the data channel. This event is deprecated and the ConfigureUpdates event should be used instead (see below)]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="period" type="float"><TypeParameters/></Member></Type><Type category="Event" name="Deleted"><Description><![CDATA[Notifies all interested clients that a specific instance of a specific scenario has been deleted.

 See also: Delete()

 Direction: From the correlator to the client.

 Channel: <scenarioId>.Data and <scenarioId>.Data.Raw]]></Description><Summary><![CDATA[Notifies all interested clients that a specific instance of a specific scenario has been deleted.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member></Type><Type category="Event" name="RequestInstancesOnChannel"><Description><![CDATA[Request that each instance of the specified scenario send an Instance event out on the supplied channel. When all instances for the scenario have been sent out, a final RequestInstancesDone event will be sent on the same channel.

 See also: Instance, RequestInstancesDone

 Direction: From the client to the correlator.

 Response: Instance() from each scenario instance.]]></Description><Summary><![CDATA[Request that each instance of the specified scenario send an Instance event out on the supplied channel. When all instances for the scenario have been sent out, a final RequestInstancesDone event will be sent on the same channel.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="channel" type="string"><TypeParameters/></Member></Type><Type category="Event" name="FinishedScenarioRecovery"><Description><![CDATA[Sweeper event to indicate that scenario recovery is done. Only used internally.]]></Description><Summary><![CDATA[Sweeper event to indicate that scenario recovery is done. Only used internally.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Type><Type category="Event" name="RequestInstancesDone"><Description><![CDATA[This is a simple marker event that is sent by the correlator to indicate that it has finished sending all of the Instance events in response to a RequestInstancesInternal event.

 See also: RequestInstancesInternal, Scenario.

 Direction: From the correlator to the client.

 Channel: A unique private channel as specified by the client in a RequestScenariosOnChannel event.

 Note that previously it would have been on <scenarioId>.Data and <scenarioId>.Data.Raw, but that behaviour is now deprecated.]]></Description><Summary><![CDATA[This is a simple marker event that is sent by the correlator to indicate that it has finished sending all of the Instance events in response to a RequestInstancesInternal event.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member></Type><Type category="Event" name="CallbackHelper"><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="callbacks" type="sequence"><Parameters><Parameter type="action"><Parameters/></Parameter></Parameters><TypeParameters/></Member><Action name="callback" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action></Type><Type category="Event" name="Acknowledge"><Description><![CDATA[A general Acknowledgement event that is the "response" to various "request" events such as Create, Edit, Delete.

 Direction: From the correlator to the client.

 Channel: <scenarioId>.Control]]></Description><Summary><![CDATA[A general Acknowledgement event that is the "response" to various "request" events such as Create, Edit, Delete.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="success" type="boolean"><TypeParameters/></Member><Member name="outputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member></Type><Type category="Event" name="ScenarioServiceUpdaterSingleInstance"><Description><![CDATA[Utility event for tracking configuration for a given scenario. This event is suitable for use by monitors which spawn per instance (e.g. Scenarios)

 This event also uses a callback to get the updates (supplied in instanceInit). If the scenario is configured to only send throttled updates, the callback is only called when the throttling period determines an update should be sent - thus, the scenario does not need to generate the output sequence<string> except when needed, which can improve performance in such a configuration.

 actions starting with an underscore should be considered private and not called by users of this event.]]></Description><Summary><![CDATA[Utility event for tracking configuration for a given scenario. This event is suitable for use by monitors which spawn per instance (e.g. Scenarios)]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Acknowledge"/><Reference package="com.apama.scenario" type="Created"/><Reference package="com.apama.scenario" type="Deleted"/><Reference package="com.apama.scenario" type="Edited"/><Reference package="com.apama.scenario" type="Instance"/><Reference package="com.apama.scenario" type="InstanceDied"/><Reference package="com.apama.scenario" type="ScenarioFinished"/><Reference package="com.apama.scenario" type="StateChange"/><Reference package="com.apama.scenario" type="Update"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Acknowledge"/><Reference package="com.apama.scenario" type="Instance"/><Reference package="com.apama.scenario" type="InstanceDied"/><Reference package="com.apama.scenario" type="OperationCompleted"/><Reference package="com.apama.scenario" type="RequestInstancesParallelDone"/><Reference package="com.apama.scenario" type="ScenarioFinished"/><Reference package="com.apama.scenario" type="StateChange"/><Reference package="com.apama.scenario" type="Update"/></Sends><Listens><Reference package="com.apama.scenario" type="SendQueuedUpdatesNow"/></Listens><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="throttlingListener" type="listener"><TypeParameters/></Member><Member name="base" package="com.apama.scenario" type="ScenarioServiceUpdaterBase"><TypeParameters/></Member><Member name="havePending" type="boolean"><TypeParameters/></Member><Member name="latestUpdate" type="float"><TypeParameters/></Member><Member name="getUpdate" type="action"><Parameters/><Returns type="sequence"><Parameters><Parameter type="string"/></Parameters></Returns><TypeParameters/></Member><Member name="update" package="com.apama.scenario" type="Update"><TypeParameters/></Member><Member name="needUpdate" type="boolean"><TypeParameters/></Member><Member name="mainContext" type="context"><TypeParameters/></Member><Member name="owner" type="string"><TypeParameters/></Member><Member name="controlChannel" type="string"><TypeParameters/></Member><Member name="rawChannel" type="string"><TypeParameters/></Member><Member name="dataChannel" type="string"><TypeParameters/></Member><Action name="emitEdited" staticNature=""><Description><![CDATA[Called to send a new Edited event.]]></Description><Summary><![CDATA[Called to send a new Edited event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Edited"/></Routes><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/><Parameter name="inputVariables" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="init" staticNature=""><Description><![CDATA[Called by monitor at onload time Will maintain configuration for this scenario]]></Description><Summary><![CDATA[Called by monitor at onload time Will maintain configuration for this scenario]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="sId" type="string"/></Parameters></Action><Action name="_configurationUpdated" staticNature=""><Description><![CDATA[called in instances (not factories) when configuration has changed]]></Description><Summary><![CDATA[called in instances (not factories) when configuration has changed]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="emitInstance" staticNature=""><Description><![CDATA[Called to send an instance in response to a RequestInstancesInternal event]]></Description><Summary><![CDATA[Called to send an instance in response to a RequestInstancesInternal event]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Instance"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Instance"/><Reference package="com.apama.scenario" type="RequestInstancesParallelDone"/></Sends><Listens/><Spawns/><Parameters><Parameter name="request" package="com.apama.scenario" type="RequestInstancesInternal"/><Parameter name="owner" type="string"/><Parameter name="state" type="string"/><Parameter name="input" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter><Parameter name="output" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="emitAcknowledgement" staticNature=""><Description><![CDATA[Called to send a new Acknowledgement event.]]></Description><Summary><![CDATA[Called to send a new Acknowledgement event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Acknowledge"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Acknowledge"/></Sends><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/></Parameters></Action><Action name="notifyInstanceDied" staticNature=""><Description><![CDATA[Called to notify the scenario service monitor that we have gone away - must be called after emitting any events regarding this instance going away. Implied by emitDeleted.]]></Description><Summary><![CDATA[Called to notify the scenario service monitor that we have gone away - must be called after emitting any events regarding this instance going away. Implied by emitDeleted.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="InstanceDied"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="InstanceDied"/></Sends><Listens/><Spawns/></Action><Action name="isRouteUpdate" staticNature=""><Description><![CDATA[Get whether this scenario should route updates]]></Description><Summary><![CDATA[Get whether this scenario should route updates]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/></Action><Action name="instanceInit" staticNature=""><Description><![CDATA[Called by monitor after spawn Will maintain configuration for this scenario, and update listeners appropriately.]]></Description><Summary><![CDATA[Called by monitor after spawn Will maintain configuration for this scenario, and update listeners appropriately.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens><Reference package="com.apama.scenario" type="SendQueuedUpdatesNow"/></Listens><Spawns/><Returns type="sequence"><Parameters><Parameter type="string"/></Parameters></Returns><Parameters><Parameter name="id" type="integer"/><Parameter name="getUpdateCallback" type="action"><Parameters/><Returns type="sequence"><Parameters><Parameter type="string"/></Parameters></Returns><Description><![CDATA[a callback to get the latest outputFieldValues - may be called at any time, must always return a consistent set of outputs]]></Description></Parameter><Parameter name="_owner" type="string"/></Parameters></Action><Action name="flushPending" staticNature=""><Description><![CDATA[flush any pending update on the throttled channel.]]></Description><Summary><![CDATA[flush any pending update on the throttled channel.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="destroy" staticNature=""><Description><![CDATA[Kill any listeners this object has started]]></Description><Summary><![CDATA[Kill any listeners this object has started]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="finished" staticNature=""><Description><![CDATA[Called when the instance has failed.  input and output are the input and output variables as at the last Update/ Edited point.]]></Description><Summary><![CDATA[Called when the instance has failed.  input and output are the input and output variables as at the last Update/ Edited point.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="ScenarioFinished"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="ScenarioFinished"/></Sends><Listens/><Spawns/><Parameters><Parameter name="state" type="string"/><Parameter name="owner" type="string"/><Parameter name="input" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter><Parameter name="output" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="init_cb" staticNature=""><Description><![CDATA[Called by monitor at onload time Will maintain configuration for this scenario. cb_init is called when initialisation is complete]]></Description><Summary><![CDATA[Called by monitor at onload time Will maintain configuration for this scenario. cb_init is called when initialisation is complete]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="sId" type="string"/><Parameter name="cb_init" type="action"><Parameters/></Parameter></Parameters></Action><Action name="newUpdateAvailable" staticNature=""><Description><![CDATA[Called when a new update is available.]]></Description><Summary><![CDATA[Called when a new update is available.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Update"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Update"/></Sends><Listens/><Spawns/></Action><Action name="emitOpCompleted" staticNature=""><Description><![CDATA[Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.]]></Description><Summary><![CDATA[Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="OperationCompleted"/></Sends><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/></Parameters></Action><Action name="_setupThrottleListener" staticNature=""><Description><![CDATA[set up a throttled listener according to throttlePeriod control]]></Description><Summary><![CDATA[set up a throttled listener according to throttlePeriod control]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="_sendThrottledUpdate" staticNature=""><Description><![CDATA[actually send an update on the throttled channel]]></Description><Summary><![CDATA[actually send an update on the throttled channel]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Update"/></Sends><Listens/><Spawns/></Action><Action name="emitCreated" staticNature=""><Description><![CDATA[Called to send a new Created event.]]></Description><Summary><![CDATA[Called to send a new Created event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Created"/></Routes><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/><Parameter name="owner" type="string"/><Parameter name="state" type="string"/><Parameter name="inputVariables" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter><Parameter name="outputVariables" type="sequence"><Parameters><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="emitInstanceDied" staticNature=""><Description><![CDATA[Called to send an instance Died event (either of failed, ended)]]></Description><Summary><![CDATA[Called to send an instance Died event (either of failed, ended)]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="InstanceDied"/></Routes><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="emitDeleted" staticNature=""><Description><![CDATA[Called to send a new Deleted event.]]></Description><Summary><![CDATA[Called to send a new Deleted event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Deleted"/></Routes><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/></Parameters></Action><Action name="emitNack" staticNature=""><Description><![CDATA[Called to send a new Nak event.]]></Description><Summary><![CDATA[Called to send a new Nak event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Acknowledge"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Acknowledge"/></Sends><Listens/><Spawns/><Parameters><Parameter name="messageId" type="integer"/></Parameters></Action><Action name="_noopAction" staticNature=""><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="emitStateChange" staticNature=""><Description><![CDATA[Called to send a new StateChange event.]]></Description><Summary><![CDATA[Called to send a new StateChange event.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="StateChange"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="StateChange"/></Sends><Listens/><Spawns/><Parameters><Parameter name="state" type="string"/></Parameters></Action></Type><Type category="Event" name="OperationCompleted"><Description><![CDATA[An operation has completed. Sent from parallel scenarios to the main context.]]></Description><Summary><![CDATA[An operation has completed. Sent from parallel scenarios to the main context.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member></Type><Type category="Event" name="RequestInstancesOnChannelByUser"><Description><![CDATA[Request that each instance for the specified user of the specified scenario send an Instance event out on the supplied channel. When all instances for the scenario have been sent out, a final RequestInstancesDone event will be sent on the same channel.

 See also: Instance, RequestInstancesDone

 Direction: From the client to the correlator.

 Response: Instance() from each scenario instance.]]></Description><Summary><![CDATA[Request that each instance for the specified user of the specified scenario send an Instance event out on the supplied channel. When all instances for the scenario have been sent out, a final RequestInstancesDone event will be sent on the same channel.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="channel" type="string"><TypeParameters/></Member><Member name="owner" type="string"><TypeParameters/></Member></Type><Type category="Event" name="ScenarioProcessedUpdates"><Description><![CDATA[Notification that a scenario has loaded a ConfigureUpdates event]]></Description><Summary><![CDATA[Notification that a scenario has loaded a ConfigureUpdates event]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member></Type><Type category="Event" name="GetAllConfiguration"><Description><![CDATA[Request all configuration]]></Description><Summary><![CDATA[Request all configuration]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="requestId" type="integer"><TypeParameters/></Member></Type><Type category="Event" name="StartScenarioRecovery"><Description><![CDATA[Only used internally to tell all the scenarios to start routing their meta data (Scenario). It is followed by a sweeper FinishedScenarioRecovery event which indicates that all the scenarios have reported in.]]></Description><Summary><![CDATA[Only used internally to tell all the scenarios to start routing their meta data (Scenario). It is followed by a sweeper FinishedScenarioRecovery event which indicates that all the scenarios have reported in.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Type><Type category="Event" name="RequestScenariosAck"><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Type><Type category="Event" name="Scenario"><Description><![CDATA[Describes the meta-information about a scenario that is loaded in the correlator.

 See also: RequestScenarios, RequestScenariosDone, ScenarioUnloaded

 Direction: From correlator to client.

 Channel:   1) com.apama.scenario to broadcast when loaded. 2) A unique private channel as specified by the client in a RequestScenarios event.

 This event has gained the executionMode field in Apama 4.2]]></Description><Summary><![CDATA[Describes the meta-information about a scenario that is loaded in the correlator.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="displayName" type="string"><TypeParameters/></Member><Member name="description" type="string"><TypeParameters/></Member><Member name="inputNames" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="inputTypes" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="inputConstraints" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="inputDefaults" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="outputNames" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="outputTypes" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="executionMode" type="integer"><TypeParameters/></Member><Member name="extraParams" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters><TypeParameters/></Member></Type><Type category="Event" name="RequestScenarios"><Description><![CDATA[Request that each scenario loaded in the correlator send its meta information out on the supplied channel. When all scenarios have sent out this information, a final RequestScenariosDone event will be sent on the same channel.

 As soon as this event is received, a RequestScenariosAck will be sent on the same channel so client can stop resending the RequestScenarios event.

 See also: Scenario, RequestScenariosDone, RequestScenariosAck

 Direction: From the client to the correlator.

 Response: Scenario() from each loaded scenario.]]></Description><Summary><![CDATA[Request that each scenario loaded in the correlator send its meta information out on the supplied channel. When all scenarios have sent out this information, a final RequestScenariosDone event will be sent on the same channel.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="channel" type="string"><TypeParameters/></Member></Type><Type category="Event" name="SendQueuedUpdatesNow"><Description><![CDATA[Immediately flushes to receivers any scenario Update events that were waiting for the next throttling period before being sent.]]></Description><Summary><![CDATA[Immediately flushes to receivers any scenario Update events that were waiting for the next throttling period before being sent.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Type><Type category="Event" name="ScenarioServiceLibrary"><Description><![CDATA[Library of utility actions]]></Description><Summary><![CDATA[Library of utility actions]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="AllConfiguration"/><Reference package="com.apama.scenario" type="Configuration"/></Routes><Emits/><Enqueues/><Sends/><Listens><Reference package="com.apama.scenario" type="ConfigureUpdates"/><Reference package="com.apama.scenario" type="GetAllConfiguration"/><Reference package="com.apama.scenario" type="GetConfiguration"/><Reference package="com.apama.scenario" type="ScenarioProcessedUpdates"/></Listens><Spawns/><Action name="getRawChannel" staticNature="static "><Description><![CDATA[Get the raw channel for a scenario ID. This channel is enabled by the sendRaw configuration key.]]></Description><Summary><![CDATA[Get the raw channel for a scenario ID. This channel is enabled by the sendRaw configuration key.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/><Parameters><Parameter name="scenarioId" type="string"/></Parameters></Action><Action name="getSendThrottled" staticNature="static "><Description><![CDATA[Get the sendThrottled value from the given configuration]]></Description><Summary><![CDATA[Get the sendThrottled value from the given configuration]]></Summary><TypeParameters/><See package="com.apama.scenario" type="ConfigureUpdates"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/><Parameters><Parameter name="defaults" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter><Parameter name="config" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="getSendThrottledUser" staticNature="static "><Description><![CDATA[Get the sendThrottledUser value from the given configuration]]></Description><Summary><![CDATA[Get the sendThrottledUser value from the given configuration]]></Summary><TypeParameters/><See package="com.apama.scenario" type="ConfigureUpdates"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/><Parameters><Parameter name="defaults" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter><Parameter name="config" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="getRawUserChannel" staticNature="static "><Description><![CDATA[Get the raw channel for a scenario Id. This channel is enabled by the sendRawUser configuration key.]]></Description><Summary><![CDATA[Get the raw channel for a scenario Id. This channel is enabled by the sendRawUser configuration key.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/><Parameters><Parameter name="channel" type="string"/><Parameter name="owner" type="string"/></Parameters></Action><Action name="getConfig" staticNature="static "><Description><![CDATA[Get the specified key from the configuration dictionaries, reverting to the default if none specified.]]></Description><Summary><![CDATA[Get the specified key from the configuration dictionaries, reverting to the default if none specified.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/><Parameters><Parameter name="defaults" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter><Parameter name="config" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter><Parameter name="key" type="string"/><Parameter name="_default" type="string"/></Parameters></Action><Action name="mergeConfiguration" staticNature="static "><Description><![CDATA[Merge configuration. Any entries in updates overwrite entries in configuration. An empty string value removes the value.]]></Description><Summary><![CDATA[Merge configuration. Any entries in updates overwrite entries in configuration. An empty string value removes the value.]]></Summary><TypeParameters/><See package="com.apama.scenario" type="ConfigureUpdates"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="updates" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter><Parameter name="configuration" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="getRouteUpdate" staticNature="static "><Description><![CDATA[Get the routeUpdate value from the given configuration]]></Description><Summary><![CDATA[Get the routeUpdate value from the given configuration]]></Summary><TypeParameters/><See package="com.apama.scenario" type="ConfigureUpdates"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/><Parameters><Parameter name="defaults" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter><Parameter name="config" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="configurationManager" staticNature="static "><TypeParameters/><Routes><Reference package="com.apama.scenario" type="AllConfiguration"/><Reference package="com.apama.scenario" type="Configuration"/></Routes><Emits/><Enqueues/><Sends/><Listens><Reference package="com.apama.scenario" type="ConfigureUpdates"/><Reference package="com.apama.scenario" type="GetConfiguration"/><Reference package="com.apama.scenario" type="ScenarioProcessedUpdates"/><Reference package="com.apama.scenario" type="GetAllConfiguration"/></Listens><Spawns/><Parameters><Parameter name="defaultConfig" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter><Parameter name="configurations" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter></Parameters></Parameter></Parameters></Action><Action name="getSendRawUser" staticNature="static "><Description><![CDATA[Get the sendRawUser value from the given configuration]]></Description><Summary><![CDATA[Get the sendRawUser value from the given configuration]]></Summary><TypeParameters/><See package="com.apama.scenario" type="ConfigureUpdates"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/><Parameters><Parameter name="defaults" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter><Parameter name="config" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="getControlChannel" staticNature="static "><Description><![CDATA[Get the control channel for a scenario Id. This channel is always enabled (uses an event set scenario ID)]]></Description><Summary><![CDATA[Get the control channel for a scenario Id. This channel is always enabled (uses an event set scenario ID)]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/><Parameters><Parameter name="scenarioId" type="string"/></Parameters></Action><Action name="getSendRaw" staticNature="static "><Description><![CDATA[Get the sendRaw value from the given configuration]]></Description><Summary><![CDATA[Get the sendRaw value from the given configuration]]></Summary><TypeParameters/><See package="com.apama.scenario" type="ConfigureUpdates"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/><Parameters><Parameter name="defaults" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter><Parameter name="config" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="getDataChannel" staticNature="static "><Description><![CDATA[Get the data channel for a scenario ID. This channel is enabled by the sendThrottled configuration key and the throttlePeriod key (Update events may be throttled)]]></Description><Summary><![CDATA[Get the data channel for a scenario ID. This channel is enabled by the sendThrottled configuration key and the throttlePeriod key (Update events may be throttled)]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/><Parameters><Parameter name="scenarioId" type="string"/></Parameters></Action><Action name="getThrottlePeriod" staticNature="static "><Description><![CDATA[Get the throttlePeriod value from the given configuration]]></Description><Summary><![CDATA[Get the throttlePeriod value from the given configuration]]></Summary><TypeParameters/><See package="com.apama.scenario" type="ConfigureUpdates"><Description/></See><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="float"/><Parameters><Parameter name="defaults" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter><Parameter name="config" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters></Parameter></Parameters></Action><Action name="getDataUserChannel" staticNature="static "><Description><![CDATA[Get the data channel for a scenario Id. This channel is enabled by the sendThrottledUser configuration key and the throttlePeriod key (Update events may be throttled)]]></Description><Summary><![CDATA[Get the data channel for a scenario Id. This channel is enabled by the sendThrottledUser configuration key and the throttlePeriod key (Update events may be throttled)]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="string"/><Parameters><Parameter name="channel" type="string"/><Parameter name="owner" type="string"/></Parameters></Action></Type><Type category="Event" name="InstanceDied"><Description><![CDATA[Indicates that a specific instance of a specific scenario has died. This is sent as a result of a scenario instance use of MonitorScript ondie. This occurs for any of deleting a running scenario, a scenario failing, or entering the end state.

 Direction: From the correlator to the client.

 Channel: <scenarioId>.Data and <scenarioId>.Data.Raw]]></Description><Summary><![CDATA[Indicates that a specific instance of a specific scenario has died. This is sent as a result of a scenario instance use of MonitorScript ondie. This occurs for any of deleting a running scenario, a scenario failing, or entering the end state.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member></Type><Type category="Event" name="StateChange"><Description><![CDATA[Indicates that a specific instance of a specific scenario has changed state, where valid states include "ENDED", "FAILED", "RUNNING".

 Direction: From the correlator to the client.

 Channel: <scenarioId>.Data and <scenarioId>.Data.Raw]]></Description><Summary><![CDATA[Indicates that a specific instance of a specific scenario has changed state, where valid states include "ENDED", "FAILED", "RUNNING".]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="state" type="string"><TypeParameters/></Member></Type><Type category="Event" name="ConfigureUpdates"><Description><![CDATA[Configures how updates are sent from scenarios. Each scenario is controlled by two configurations - a global default, and an optional per scenario configuration.  The per scenario configuration takes precedence over the global default. The configuration is made up of a number of entries in the configuration dictionary. The ConfigureUpdate event is merged into any previous configuration.

 Global configuration can be modified by specifying an empty string for scenarioId, and empty values remove values.]]></Description><Summary><![CDATA[Configures how updates are sent from scenarios. Each scenario is controlled by two configurations - a global default, and an optional per scenario configuration.  The per scenario configuration takes precedence over the global default. The configuration is made up of a number of entries in the configuration dictionary. The ConfigureUpdate event is merged into any previous configuration.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><Description><![CDATA[Specifies the scenario the configuratio will apply to, or use empty string "" to specify a global default.]]></Description><Summary><![CDATA[Specifies the scenario the configuratio will apply to, or use empty string "" to specify a global default.]]></Summary><TypeParameters/></Member><Member name="configuration" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters><Description><![CDATA[A set of the configurations modified by this event the key and meaning is one of: sendThrottled - boolean - whether to send Updates to the Throttled (.Data) channel (default=true) throttlePeriod - float - period with which to send Updates. 0.0 means updates are not throttled - every update is sent on the Throttled channel. (default=0.0) sendRaw - boolean - whether to send Updates on the Raw channel (.Raw) (default=true) sendThrottledUser - boolean - whether to send Updates to the throttled filtered (.Data:username) channel (default=false) sendRawUser - boolean - whether to send Updates to the Raw channel (.Raw:username) (default=false) routeUpdate - boolean - whether to route Update (and Edited, Deleted) events. An empty value removes that entry from the configuration]]></Description><Summary><![CDATA[A set of the configurations modified by this event the key and meaning is one of: sendThrottled - boolean - whether to send Updates to the Throttled (.Data) channel (default=true) throttlePeriod - float - period with which to send Updates. 0.0 means updates are not throttled - every update is sent on the Throttled channel. (default=0.0) sendRaw - boolean - whether to send Updates on the Raw channel (.Raw) (default=true) sendThrottledUser - boolean - whether to send Updates to the throttled filtered (.Data:username) channel (default=false) sendRawUser - boolean - whether to send Updates to the Raw channel (.Raw:username) (default=false) routeUpdate - boolean - whether to route Update (and Edited, Deleted) events. An empty value removes that entry from the configuration]]></Summary><TypeParameters/></Member></Type><Type category="Event" name="GetConfiguration"><Description><![CDATA[Get the current configuration for a given scenario and the default configuration]]></Description><Summary><![CDATA[Get the current configuration for a given scenario and the default configuration]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member></Type><Type category="Event" name="Edited"><Description><![CDATA[Notifies all interested clients that a specific instance of a specific scenario has been edited (the input field values have changed).

 See also: Edit()

 Direction: From the correlator to the client.

 Channel: <scenarioId>.Data and <scenarioId>.Data.Raw]]></Description><Summary><![CDATA[Notifies all interested clients that a specific instance of a specific scenario has been edited (the input field values have changed).]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="messageId" type="integer"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="inputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="outputFieldValues" type="sequence"><Parameters><Parameter type="string"/></Parameters><TypeParameters/></Member></Type><Type category="Event" name="ScenarioServiceUpdaterBase"><Description><![CDATA[Base event for tracking configuration for a given scenario]]></Description><Summary><![CDATA[Base event for tracking configuration for a given scenario]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="GetConfiguration"/><Reference package="com.apama.scenario" type="ScenarioProcessedUpdates"/></Routes><Emits><Reference type="string representation of an event"/></Emits><Enqueues/><Sends/><Listens><Reference package="com.apama.scenario" type="Configuration"/><Reference package="com.apama.scenario" type="ConfigureUpdates"/></Listens><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="defaultConfig" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="config" type="dictionary"><Parameters><Parameter type="string"/><Parameter type="string"/></Parameters><TypeParameters/></Member><Member name="sendThrottled" type="boolean"><TypeParameters/></Member><Member name="sendRaw" type="boolean"><TypeParameters/></Member><Member name="sendAny" type="boolean"><TypeParameters/></Member><Member name="emitAny" type="boolean"><TypeParameters/></Member><Member name="sendThrottledUser" type="boolean"><TypeParameters/></Member><Member name="sendRawUser" type="boolean"><TypeParameters/></Member><Member name="routeUpdate" type="boolean"><TypeParameters/></Member><Member name="throttlePeriod" type="float"><TypeParameters/></Member><Member name="throttleStart" type="float"><TypeParameters/></Member><Member name="listeners" type="sequence"><Parameters><Parameter type="listener"/></Parameters><TypeParameters/></Member><Member name="controlChannel" type="string"><TypeParameters/></Member><Member name="rawChannel" type="string"><TypeParameters/></Member><Member name="dataChannel" type="string"><TypeParameters/></Member><Action name="init" staticNature=""><Description><![CDATA[Called by monitor at onload time Will maintain configuration for this scenario]]></Description><Summary><![CDATA[Called by monitor at onload time Will maintain configuration for this scenario]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="GetConfiguration"/></Routes><Emits/><Enqueues/><Sends/><Listens><Reference package="com.apama.scenario" type="Configuration"/></Listens><Spawns/><Parameters><Parameter name="sId" type="string"><Description><![CDATA[the scenarioId]]></Description></Parameter><Parameter name="cb_onUpdate" type="action"><Parameters/></Parameter></Parameters></Action><Action name="isSendRaw" staticNature=""><Description><![CDATA[Get whether this scenario should send on the raw channel]]></Description><Summary><![CDATA[Get whether this scenario should send on the raw channel]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/></Action><Action name="onConfigureUpdates" staticNature=""><Description><![CDATA[Called when new ConfigureUpdates event available]]></Description><Summary><![CDATA[Called when new ConfigureUpdates event available]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="cu" package="com.apama.scenario" type="ConfigureUpdates"/></Parameters></Action><Action name="isSendThrottled" staticNature=""><Description><![CDATA[Get whether this scenario should send on the throttled (Data) channel]]></Description><Summary><![CDATA[Get whether this scenario should send on the throttled (Data) channel]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Returns type="boolean"/></Action><Action name="configurationUpdated" staticNature=""><Description><![CDATA[Called when the configuration should be re-parsed.]]></Description><Summary><![CDATA[Called when the configuration should be re-parsed.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="destroy" staticNature=""><Description><![CDATA[Kill any listeners this object has started]]></Description><Summary><![CDATA[Kill any listeners this object has started]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Action><Action name="listenToConfigureUpdates" staticNature=""><Description><![CDATA[Listen for further configuration changes.]]></Description><Summary><![CDATA[Listen for further configuration changes.]]></Summary><TypeParameters/><Routes><Reference package="com.apama.scenario" type="ScenarioProcessedUpdates"/></Routes><Emits/><Enqueues/><Sends/><Listens><Reference package="com.apama.scenario" type="ConfigureUpdates"/></Listens><Spawns/><Parameters><Parameter name="cb_onUpdate" type="action"><Parameters/><Description><![CDATA[callback upon configuration having been updated]]></Description></Parameter></Parameters></Action><Action name="doEmit" staticNature=""><TypeParameters/><Routes/><Emits><Reference type="string representation of an event"/></Emits><Enqueues/><Sends/><Listens/><Spawns/><Parameters><Parameter name="emitted" type="string"/><Parameter name="owner" type="string"/></Parameters></Action></Type><Type category="Event" name="ParallelStarting"><Description><![CDATA[Notification of a new scenario instance]]></Description><Summary><![CDATA[Notification of a new scenario instance]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/><Member name="scenarioId" type="string"><TypeParameters/></Member><Member name="scenarioInstanceId" type="integer"><TypeParameters/></Member><Member name="owner" type="string"><TypeParameters/></Member><Member name="runningCtx" type="context"><TypeParameters/></Member></Type><Type category="Event" name="RequestScenariosDone"><Description><![CDATA[This is a simple marker event that is sent by the correlator to indicate that it has finished sending all of the Scenario events in response to a RequestScenarios event.

 See also: RequestScenarios, Scenario.

 Direction: From the correlator to the client.

 Channel: The private channel that was specified in the RequestScenarios event.]]></Description><Summary><![CDATA[This is a simple marker event that is sent by the correlator to indicate that it has finished sending all of the Scenario events in response to a RequestScenarios event.]]></Summary><TypeParameters/><Routes/><Emits/><Enqueues/><Sends/><Listens/><Spawns/></Type><Type category="Monitor" name="RequestInstancesHandler"><TypeParameters/><Routes><Reference package="com.apama.scenario" type="RequestInstancesDone"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="RequestInstancesInternal"/></Sends><Listens><Reference package="com.apama.scenario" type="InstanceDied"/><Reference package="com.apama.scenario" type="RequestInstancesParallel"/><Reference package="com.apama.scenario" type="RequestInstancesParallelDone"/><Reference package="com.apama.scenario" type="ScenarioFinished"/></Listens></Type><Type category="Monitor" name="ScenarioService"><TypeParameters/><Routes><Reference package="com.apama.scenario" type="Acknowledge"/><Reference package="com.apama.scenario" type="ConfigureUpdates"/><Reference package="com.apama.scenario" type="Delete"/><Reference package="com.apama.scenario" type="Edit"/><Reference package="com.apama.scenario" type="FinishedScenarioRecovery"/><Reference package="com.apama.scenario" type="RequestInstancesInternal"/><Reference package="com.apama.scenario" type="RequestInstancesParallel"/><Reference package="com.apama.scenario" type="ScenarioServiceLoaded"/><Reference package="com.apama.scenario" type="ScenarioServiceUnloaded"/><Reference package="com.apama.scenario" type="StartScenarioRecovery"/></Routes><Emits/><Enqueues/><Sends><Reference package="com.apama.scenario" type="Acknowledge"/><Reference package="com.apama.scenario" type="ConfigureUpdates"/><Reference package="com.apama.scenario" type="Delete"/><Reference package="com.apama.scenario" type="Edit"/><Reference package="com.apama.scenario" type="RequestInstancesDone"/><Reference package="com.apama.scenario" type="RequestScenariosAck"/><Reference package="com.apama.scenario" type="RequestScenariosDone"/><Reference package="com.apama.scenario" type="Scenario"/><Reference package="com.apama.scenario" type="ScenarioServiceLoaded"/><Reference package="com.apama.scenario" type="ScenarioServiceUnloaded"/><Reference package="com.apama.scenario" type="ScenarioUnloaded"/><Reference package="com.apama.scenario" type="SendQueuedUpdatesNow"/></Sends><Listens><Reference package="com.apama.scenario" type="ConfigureUpdates"/><Reference package="com.apama.scenario" type="Create"/><Reference package="com.apama.scenario" type="Delete"/><Reference package="com.apama.scenario" type="Edit"/><Reference package="com.apama.scenario" type="FinishedScenarioRecovery"/><Reference package="com.apama.scenario" type="InstanceDied"/><Reference package="com.apama.scenario" type="OperationCompleted"/><Reference package="com.apama.scenario" type="ParallelStarting"/><Reference package="com.apama.scenario" type="RequestInstancesDone"/><Reference package="com.apama.scenario" type="RequestInstancesInternal"/><Reference package="com.apama.scenario" type="RequestInstancesOnChannel"/><Reference package="com.apama.scenario" type="RequestInstancesOnChannelByUser"/><Reference package="com.apama.scenario" type="RequestScenarios"/><Reference package="com.apama.scenario" type="Scenario"/><Reference package="com.apama.scenario" type="ScenarioFinished"/><Reference package="com.apama.scenario" type="ScenarioUnloaded"/><Reference package="com.apama.scenario" type="SendQueuedUpdatesNow"/><Reference package="com.apama.scenario" type="SetThrottlingPeriod"/></Listens></Type></Package></Packages>